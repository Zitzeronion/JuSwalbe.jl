var documenterSearchIndex = {"docs":
[{"location":"manual/#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Short and clean instructions how to use the Package. Functions and methods can be found here with usage examples.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Modules = [JuSwalbe]\nOrder = [:function, :type, :struct] ","category":"page"},{"location":"manual/#JuSwalbe.calc_equilibrium_distribution-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T<:Number","page":"Manual","title":"JuSwalbe.calc_equilibrium_distribution","text":"calc_equilibrium_distribution(mom::JuSwalbe.Macroquant; gravity=0)\n\nCalculates the equilibrium distributions based on the macroscopic quantities mom and gravitational acceleration gravity.\n\nThe equilibrium distribtutions are at the heart of the lattice Boltzmann method. As the expansion is made around the equilibrium, lattice Boltzmann always assumes that the flow field is close to equilibrium. Therefore the equilibrium is calculated from macroscopic quantities, i.e. height .height and velocity .velocity.\n\nMath:\n\nOne spatial dimension\n\nDefining equations in one spatial dimensions are expressed in the following way\n\nf_0^eq =  h - frac12v^2gh^2 - frac1v^2hu^2 \n\nf_1^eq =  frac14v^2gh^2 + frac12vhu + frac12v^2hu^2\n\nf_2^eq =  frac14v^2gh^2 - frac12vhu + frac12v^2hu^2\n\nTwo spatial dimension\n\nIn two spatial dimensions the velocity because a vector with a x and y component. Such the equations look a little more complex\n\nf_0^eq =  h - frac49h(frac152gh - frac32u^2)\n\nf_i^eq = w_i h(frac32gh + 3 mathbfc_icdotmathbfu + frac92(mathbfc_icdotmathbfu)^2 - frac32u^2))\n\nwith i are the number of lattice speeds and wi and ci are the weights and sets of lattice velocities.\n\nExample\n\nTwo spatial dimensions\n\njulia> using JuSwalbe\n\njulia> mom = JuSwalbe.Macroquant(height=ones(4,4), velocity=JuSwalbe.Twovector(x=fill(0.1, (4,4)), y=fill(-0.1, (4,4))), pressure=zeros(4,4), energy=zeros(4,4))\nJuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}\n  height: Array{Float64}((4, 4)) [1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0]\n  velocity: JuSwalbe.Twovector{Array{Float64,2}}\n  pressure: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]\n  energy: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]\n\njulia> equilibrium = calc_equilibrium_distribution(mom)\nJuSwalbe.DistributionD2Q9{Array{Float64,2}}\n  f0: Array{Float64}((4, 4)) [0.9866666666666667 0.9866666666666667 0.9866666666666667 0.9866666666666667; 0.9866666666666667 0.9866666666666667 0.9866666666666667 0.9866666666666667; 0.9866666666666667 0.9866666666666667 0.9866666666666667 0.9866666666666667; 0.9866666666666667 0.9866666666666667 0.9866666666666667 0.9866666666666667]\n  f1: Array{Float64}((4, 4)) [0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035]\n  f2: Array{Float64}((4, 4)) [-0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667]\n  f3: Array{Float64}((4, 4)) [-0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667]\n  f4: Array{Float64}((4, 4)) [0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035]\n  f5: Array{Float64}((4, 4)) [-0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335]\n  f6: Array{Float64}((4, 4)) [-0.0125 -0.0125 -0.0125 -0.0125; -0.0125 -0.0125 -0.0125 -0.0125; -0.0125 -0.0125 -0.0125 -0.0125; -0.0125 -0.0125 -0.0125 -0.0125]\n  f7: Array{Float64}((4, 4)) [-0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335]\n  f8: Array{Float64}((4, 4)) [0.020833333333333336 0.020833333333333336 0.020833333333333336 0.020833333333333336; 0.020833333333333336 0.020833333333333336 0.020833333333333336 0.020833333333333336; 0.020833333333333336 0.020833333333333336 0.020833333333333336 0.020833333333333336; 0.020833333333333336 0.020833333333333336 0.020833333333333336 0.020833333333333336]\n\njulia> arr = dist2array(equilibrium)\n9×4×4 Array{Float64,3}:\n[:, :, 1] =\n  0.986667      0.986667      0.986667      0.986667\n  0.035         0.035         0.035         0.035\n -0.0316667    -0.0316667    -0.0316667    -0.0316667\n -0.0316667    -0.0316667    -0.0316667    -0.0316667\n  0.035         0.035         0.035         0.035\n -0.000833333  -0.000833333  -0.000833333  -0.000833333\n -0.0125       -0.0125       -0.0125       -0.0125\n -0.000833333  -0.000833333  -0.000833333  -0.000833333\n  0.0208333     0.0208333     0.0208333     0.0208333\n\n[:, :, 2] =\n  0.986667      0.986667      0.986667      0.986667\n  0.035         0.035         0.035         0.035\n -0.0316667    -0.0316667    -0.0316667    -0.0316667\n -0.0316667    -0.0316667    -0.0316667    -0.0316667\n  0.035         0.035         0.035         0.035\n -0.000833333  -0.000833333  -0.000833333  -0.000833333\n -0.0125       -0.0125       -0.0125       -0.0125\n -0.000833333  -0.000833333  -0.000833333  -0.000833333\n  0.0208333     0.0208333     0.0208333     0.0208333\n\n[:, :, 3] =\n  0.986667      0.986667      0.986667      0.986667\n  0.035         0.035         0.035         0.035\n -0.0316667    -0.0316667    -0.0316667    -0.0316667\n -0.0316667    -0.0316667    -0.0316667    -0.0316667\n  0.035         0.035         0.035         0.035\n -0.000833333  -0.000833333  -0.000833333  -0.000833333\n -0.0125       -0.0125       -0.0125       -0.0125\n -0.000833333  -0.000833333  -0.000833333  -0.000833333\n  0.0208333     0.0208333     0.0208333     0.0208333\n\n[:, :, 4] =\n  0.986667      0.986667      0.986667      0.986667\n  0.035         0.035         0.035         0.035\n -0.0316667    -0.0316667    -0.0316667    -0.0316667\n -0.0316667    -0.0316667    -0.0316667    -0.0316667\n  0.035         0.035         0.035         0.035\n -0.000833333  -0.000833333  -0.000833333  -0.000833333\n -0.0125       -0.0125       -0.0125       -0.0125\n -0.000833333  -0.000833333  -0.000833333  -0.000833333\n  0.0208333     0.0208333     0.0208333     0.0208333\n\njulia> h = sum(arr, dims=1)[1,:,:] # Check consistency \n4×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\n\nOne spatial dimension\n\njulia> using JuSwalbe\n\njulia> mom = JuSwalbe.Macroquant(height=ones(5), velocity=fill(0.1, 5), pressure=zeros(5), energy=zeros(5))\nJuSwalbe.Macroquant{Array{Float64,1},Array{Float64,1}}\n  height: Array{Float64}((5,)) [1.0, 1.0, 1.0, 1.0, 1.0]\n  velocity: Array{Float64}((5,)) [0.1, 0.1, 0.1, 0.1, 0.1]\n  pressure: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]\n  energy: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]\n\njulia> equilibrium = calc_equilibrium_distribution(mom)\nJuSwalbe.DistributionD1Q3{Array{Float64,1}}\n  f0: Array{Float64}((5,)) [0.99, 0.99, 0.99, 0.99, 0.99]\n  f1: Array{Float64}((5,)) [0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001]\n  f2: Array{Float64}((5,)) [-0.045, -0.045, -0.045, -0.045, -0.045]\n\njulia> h = sum(hcat(equilibrium.f0, equilibrium.f1, equilibrium.f2), dims=2)[:,1]\n5-element Array{Float64,1}:\n 0.9999999999999999\n 0.9999999999999999\n 0.9999999999999999\n 0.9999999999999999\n 0.9999999999999999\n\njulia> h[1] - 1.0 # fits up to machine precision\n-1.1102230246251565e-16\n\n\nReferences\n\nCode\n\nSee also: velocitysquared\n\nOne spatial dimension\n\nThere are plenty of ways to calculate them I mainly the ones derived in Eq.(13) of Study of the 1D lattice Boltzmann shallow water equation and its coupling to build a canal network.\n\nTwo spatial dimensions\n\nHere I stick to the paper written by Paul Dellar, Eq.(26) of Nonhydrodynamic modes and a priori construction of shallow water lattice Boltzmann equations Originally these equilibria have been worked out by Paul Salmon.\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.calculatemoments-Union{Tuple{JuSwalbe.DistributionD1Q3{Array{T,1}}}, Tuple{T}} where T<:Number","page":"Manual","title":"JuSwalbe.calculatemoments","text":"calculatemoments(dist)\n\nComputes the lattice Boltzmann moments (h,v) from a distribution function dist.\n\nBased on the input either a D1Q3 or a D2Q9 distribution this function performs a summation over the particle speeds. In one spatial dimension the velocity set [-1, 0, 1] allows for three speeds in two for nine speeds. See also: dist2array\n\nMath\n\nThe moments are calculated according to \n\nrho = sum_i=0^N f_i\n\nrhomathbfu = sum_i=0^N mathbfc_i f_i\n\ne = sum_i=0^N mathbfc_i mathbfc_i f_i\n\nWhere N is either 3 or 9. In one spatial dimension the velocity is of course not a vector of (xy).\n\nExample\n\njulia> using JuSwalbe\n\njulia> a = fill(0.1, (10, 10))\n10×10 Array{Float64,2}:\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n\njulia> b = fill(0.2, (10,10))\n10×10 Array{Float64,2}:\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2\n\njulia> dist = JuSwalbe.DistributionD2Q9(f0=a,f1=b,f2=a,f3=a,f4=a,f5=a,f6=a,f7=a,f8=a)\nJuSwalbe.DistributionD2Q9{Array{Float64,2}}\n  f0: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f1: Array{Float64}((10, 10)) [0.2 0.2 … 0.2 0.2; 0.2 0.2 … 0.2 0.2; … ; 0.2 0.2 … 0.2 0.2; 0.2 0.2 … 0.2 0.2]\n  f2: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f3: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f4: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f5: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f6: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f7: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f8: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n\njulia> mom = calculatemoments(dist)\nJuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}\n  height: Array{Float64}((10, 10)) [0.9999999999999999 0.9999999999999999 … 0.9999999999999999 0.9999999999999999; 0.9999999999999999 0.9999999999999999 … 0.9999999999999999 0.9999999999999999; … ; 0.9999999999999999 0.9999999999999999 … 0.9999999999999999 0.9999999999999999; 0.9999999999999999 0.9999999999999999 … 0.9999999999999999 0.9999999999999999]\n  velocity: JuSwalbe.Twovector{Array{Float64,2}}\n  pressure: Array{Float64}((10, 10)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  energy: Array{Float64}((10, 10)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n\njulia> mom.height\n10×10 Array{Float64,2}:\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0\n\njulia> mom.velocity.x\n10×10 Array{Float64,2}:\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1\n\njulia> mom.velocity.y\n10×10 Array{Float64,2}:\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> dist1d = JuSwalbe.DistributionD1Q3(f0=a[1:10],f1=b[1:10],f2=a[1:10]) # Vectorize a and b\nJuSwalbe.DistributionD1Q3{Array{Float64,1}}\n  f0: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]\n  f1: Array{Float64}((10,)) [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]\n  f2: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]\n\njulia> mom1d = calculatemoments(dist1d)\nJuSwalbe.Macroquant{Array{Float64,1},Array{Float64,1}}\n  height: Array{Float64}((10,)) [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4]\n  velocity: Array{Float64}((10,)) [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]\n  pressure: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  energy: Array{Float64}((10,)) [0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004]\n\njulia> mom1d.height\n10-element Array{Float64,1}:\n 0.4\n 0.4\n 0.4\n 0.4\n 0.4\n 0.4\n 0.4\n 0.4\n 0.4\n 0.4\n\n\njulia> mom1d.velocity\n10-element Array{Float64,1}:\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n 0.25\n\n\nReferences\n\nCode\n\nSee also: dist2array\n\nTwo spatial dimensions\n\nHere I go with Dellar\n\nNonhydrodynamic modes and a priori construction of shallow water lattice Boltzmann equations\n\nOne spatial dimension\n\nFor the one dimensional simulation the paper by Chopard is quite nice\n\nStudy of the 1D lattice Boltzmann shallow water equation and its coupling to build a canal network.\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.collisionBGK-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}},JuSwalbe.DistributionD1Q3{Array{T,1}},JuSwalbe.Inputconstants}} where T<:Number","page":"Manual","title":"JuSwalbe.collisionBGK","text":"collisionBGK(mom, tempdist, input)\n\nComputes the BGK collision operation for a D1Q3 and a D2Q9 lattice Boltzmann algorithm.\n\nThe collision operator is the central object in kinetic theory.  However there is no general solution for this operator.  One work around is to make assumptions and try to model them.  The BGK operator is one of the fairly successful operators.  It stems from the idea that the distributions are close to their equilibria and that all of them relax with a single relaxation time τ.\n\nMath\n\nThe collision operator is usually the right hand side of the kinetic equation \n\npartial_t f + fracmathbfpmcdotnabla f + mathbfFcdot partial_mathbfp f = Omega \n\nAfter tedious mathematics and expansions one can obtain the simplest collision operator the BGK as\n\nOmega_BGK = -fracf - f^eqtau\n\nwith τ being the relaxation parameter. \n\nExample\n\nOne spatial dimension\n\njulia> using JuSwalbe\n\njulia> input, mom, force, dist = minimalsetup1d(10)\n(JuSwalbe.Inputconstants\n  lx: Int64 10\n  ly: Int64 512\n  maxruntime: Int64 100000\n  dumping: Int64 1000\n  τ: Float64 1.0\n  gravity: Float64 0.0\n  γ: Float64 0.01\n  δ: Float64 1.0\n  μ: Float64 0.16666666666666666\n, JuSwalbe.Macroquant{Array{Float64,1},Array{Float64,1}}\n  height: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  velocity: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]\n  pressure: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  energy: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n, JuSwalbe.Forces{Array{Float64,1}}\n  slip: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]\n  h∇p: Array{Float64}((10,)) [-0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1]\n  bathymetry: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  thermal: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n, JuSwalbe.DistributionD1Q3{Array{Float64,1}}\n  f0: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  f1: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  f2: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n)\n\njulia> force.slip = zeros(10)\n10-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\njulia> force.h∇p = zeros(10)\n10-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\njulia> newdist = collisionBGK(mom, force, dist, input)\nJuSwalbe.DistributionD1Q3{Array{Float64,1}}\n  f0: Array{Float64}((10,)) [0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99]\n  f1: Array{Float64}((10,)) [0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001]\n  f2: Array{Float64}((10,)) [-0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045]\n\njulia> equi = calc_equilibrium_distribution(mom, gravity=input.gravity)\nJuSwalbe.DistributionD1Q3{Array{Float64,1}}\n  f0: Array{Float64}((10,)) [0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99]\n  f1: Array{Float64}((10,)) [0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001]\n  f2: Array{Float64}((10,)) [-0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045]\n\njulia> using Test; @test equi.f0 == newdist.f0 # without forces and τ = 1 they have to be equal\nTest Passed\n\nReferences\n\nOne spatial dimension\n\nAsymmetric lattice Boltzmann model for shallow water flows\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.computeslip-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}},JuSwalbe.Inputconstants}} where T<:Number","page":"Manual","title":"JuSwalbe.computeslip","text":"computeslip(mom, δ, force)\n\nCalculates the force due to slippage on the substrate.\n\nSince the model only alows for forces in x and y direction but not in z it is necessary to regularize the velocity at h rightarrow 0. The so called no-slip boundary condition can be in theory implemented using δ = 0.  However as soon as the film dewets and height becomes small, the solution diverges. Choosing δ = 1 satisfies the weak slip condition, while choosing it much larger than 1 yields the strong slip solution.\n\nMath\n\nOne and two dimensional approaches are essentially equal. Behind the force is the idea of a parabolic shape of the velocity along z. With the boundary conditions\n\nmathbfu_h=H = mathbfu\n\nmathbfu_h=0 = 0\n\nThe parameter δ allows to push the zero velocity into the substrate, such below te computable region. Solving this equation with some more assumptions yields\n\nmathbfF_slip = mualpha_delta(h) mathbfu = frac6mu h mathbfu2 h^2 + 6delta h + 3delta^2\n\nExample\n\nReferences\n\nHere I shamelessly cite the paper from within our group \n\nLattice Boltzmann method for thin-liquid-film hydrodynamics\n\nSee also: Inputconstants, calculatemoments\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.dist2array-Union{Tuple{JuSwalbe.DistributionD2Q9{Array{T,2}}}, Tuple{T}} where T<:Number","page":"Manual","title":"JuSwalbe.dist2array","text":"dist2array(dist)\n\nTransforms the D2Q9 struct into a three dimensional array.\n\nAxis are chosen such that it can be easily multiplied with the nine speed lattice speeds. The function also excepts a Forces struct as input and returns a three dimensional array for both x and y.\n\nExample\n\njulia> using JuSwalbe\n\njulia> a = fill(0.1, (5,5))\n5×5 Array{Float64,2}:\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n\njulia> b = fill(0.2, (5,5))\n5×5 Array{Float64,2}:\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n 0.2  0.2  0.2  0.2  0.2\n\njulia> dist = JuSwalbe.DistributionD2Q9(f0=a, f1=b, f2=a, f3=a, f4=a, f5=a, f6=a, f7=a, f8=a)\nJuSwalbe.DistributionD2Q9{Array{Float64,2}}\n  f0: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f1: Array{Float64}((5, 5)) [0.2 0.2 … 0.2 0.2; 0.2 0.2 … 0.2 0.2; … ; 0.2 0.2 … 0.2 0.2; 0.2 0.2 … 0.2 0.2]\n  f2: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f3: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f4: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f5: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f6: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f7: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n  f8: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]\n\njulia> arr = dist2array(dist)\n9×5×5 Array{Float64,3}:\n[:, :, 1] =\n 0.1  0.1  0.1  0.1  0.1\n 0.2  0.2  0.2  0.2  0.2\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n\n[:, :, 2] =\n 0.1  0.1  0.1  0.1  0.1\n 0.2  0.2  0.2  0.2  0.2\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n\n[:, :, 3] =\n 0.1  0.1  0.1  0.1  0.1\n 0.2  0.2  0.2  0.2  0.2\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n\n[:, :, 4] =\n 0.1  0.1  0.1  0.1  0.1\n 0.2  0.2  0.2  0.2  0.2\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n\n[:, :, 5] =\n 0.1  0.1  0.1  0.1  0.1\n 0.2  0.2  0.2  0.2  0.2\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1  0.1\n\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.findargument-Tuple{Array{Any,2},String}","page":"Manual","title":"JuSwalbe.findargument","text":"findargument(arr, str)\n\nSearches for a numerical value based on a str input and returns the value.\n\nExample\n\njulia> using JuSwalbe\n\njulia> arr = [\"hmm\" 1; \"yeah\" 0.01; \"world\" 1090]\n3×2 Array{Any,2}:\n \"hmm\"       1\n \"yeah\"      0.01\n \"world\"  1090\n\njulia> world = findargument(arr, \"world\")\n1090\n\n\nReferences\n\nSee also: readinput\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.minimalsetup1d-Tuple{Int64}","page":"Manual","title":"JuSwalbe.minimalsetup1d","text":"minimalsetup1d(N)\n\nCreates a minimal setup of all important variables.\n\nSuch it generates the moments height, velocity as well as a dummy distribution with its speeds f0, f1 and f2. Further a set of forcing is supplied, they can be used with foces.slip, .h∇p, .bathymetry and .thermal.\n\nExample\n\njulia> using JuSwalbe\n\njulia> constants, mom, f, distribution = minimalsetup1d(10)\n(JuSwalbe.Inputconstants\n  lx: Int64 10\n  ly: Int64 512\n  maxruntime: Int64 100000\n  dumping: Int64 1000\n  τ: Float64 1.0\n  gravity: Float64 0.0\n  γ: Float64 0.01\n  δ: Float64 1.0\n  μ: Float64 0.16666666666666666\n, JuSwalbe.Macroquant{Array{Float64,1},Array{Float64,1}}\n  height: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  velocity: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]\n  pressure: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  energy: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n, JuSwalbe.Forces{Array{Float64,1}}\n  slip: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]\n  h∇p: Array{Float64}((10,)) [-0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1]\n  bathymetry: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  thermal: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n, JuSwalbe.DistributionD1Q3{Array{Float64,1}}\n  f0: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  f1: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  f2: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n)\n\njulia> mom.height\n10-element Array{Float64,1}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\nSee also: minimalsetup2d\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.minimalsetup2d-Tuple{Int64,Int64}","page":"Manual","title":"JuSwalbe.minimalsetup2d","text":"minimalsetup2d(N,M)\n\nCreates a minimal working example set of macroscopic moments, forces and a distribution.\n\nExample\n\njulia> using JuSwalbe\n\njulia> input, mom, f, dist = minimalsetup2d(5,5)\n(JuSwalbe.Inputconstants\n  lx: Int64 5\n  ly: Int64 5\n  maxruntime: Int64 100000\n  dumping: Int64 1000\n  τ: Float64 1.0\n  gravity: Float64 0.0\n  γ: Float64 0.01\n  δ: Float64 1.0\n  μ: Float64 0.16666666666666666\n, JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}\n  height: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]\n  velocity: JuSwalbe.Twovector{Array{Float64,2}}\n  pressure: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  energy: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n, JuSwalbe.Forces{JuSwalbe.Twovector{Array{Float64,2}}}\n  slip: JuSwalbe.Twovector{Array{Float64,2}}\n  h∇p: JuSwalbe.Twovector{Array{Float64,2}}\n  bathymetry: JuSwalbe.Twovector{Array{Float64,2}}\n  thermal: JuSwalbe.Twovector{Array{Float64,2}}\n, JuSwalbe.DistributionD2Q9{Array{Float64,2}}\n  f0: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]\n  f1: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  f2: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  f3: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  f4: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  f5: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  f6: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  f7: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  f8: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n)\n\n\nSee also: minimalsetup1d\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.pressure-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T<:Number","page":"Manual","title":"JuSwalbe.pressure","text":"pressure(mom::JuSwalbe.Macroquant; γ = 0.01, θ = 1/9)\n\nFilm pressure of the thin film equation.\n\nThis is just the summation of the laplacian of the height Δh and the disjoining potential Π. Since this function uses Π one has to be careful of θ as it should be an array. However it can be either a single element array or as large as the whole domain. See also: Δh, Π\n\nMath\n\nThe film pressure is simply\n\np_film = -gammaDelta h + Pi(h)\n\nThe sign is not 100% fixed and can change from paper to paper. Here I choose to be in agreement with Thiele et al., which is known to be a good theoretician. \n\nExample\n\njulia> using JuSwalbe\n\njulia> height = reshape([i for i in 1.0:1.0:16.0],4,4)\n4×4 Array{Float64,2}:\n 1.0  5.0   9.0  13.0\n 2.0  6.0  10.0  14.0\n 3.0  7.0  11.0  15.0\n 4.0  8.0  12.0  16.0\n\njulia> p = pressure(height)\n4×4 Array{Float64,2}:\n -0.200016  -0.0400001   -0.04        0.12\n -0.160002  -7.44536e-8  -1.6082e-8   0.16\n -0.160001  -4.68862e-8  -1.20826e-8  0.16\n -0.12       0.04         0.04        0.2\n\njulia> mom = JuSwalbe.Macroquant(height=height, velocity=JuSwalbe.Twovector(x=zeros(4,4), y=zeros(4,4)), pressure=zeros(4,4), energy=zeros(4,4))\nJuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}\n  height: Array{Float64}((4, 4)) [1.0 5.0 9.0 13.0; 2.0 6.0 10.0 14.0; 3.0 7.0 11.0 15.0; 4.0 8.0 12.0 16.0]\n  velocity: JuSwalbe.Twovector{Array{Float64,2}}\n  pressure: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]\n  energy: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]\n\njulia> mom.pressure\n4×4 Array{Float64,2}:\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\njulia> pressure(mom) # Pressure is stored in the moments struct!\n4×4 Array{Float64,2}:\n -0.200016  -0.0400001   -0.04        0.12\n -0.160002  -7.44536e-8  -1.6082e-8   0.16\n -0.160001  -4.68862e-8  -1.20826e-8  0.16\n -0.12       0.04         0.04        0.2\n\njulia> mom.pressure\n4×4 Array{Float64,2}:\n -0.200016  -0.0400001   -0.04        0.12\n -0.160002  -7.44536e-8  -1.6082e-8   0.16\n -0.160001  -4.68862e-8  -1.20826e-8  0.16\n -0.12       0.04         0.04        0.2\n\n\nSo what does this mean? A positive pressure is force that drives the film down in height. While a negative pressure generates a flux towards that location. In the example a linear increasing height field was used, an equilibrium though is reached when the film is flat.\n\nReferences\n\nRecent (short)\n\nSignatures of slip in dewetting polymer films\n\nReview\n\nDynamics and stability of thin liquid films\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.readinput-Tuple{Any}","page":"Manual","title":"JuSwalbe.readinput","text":"readinput(file)\n\nReads input parameters from a file.\n\nThe expected amount of parameters can be addressed with Inputconstants. For now it expects seven values for different runtime constants.\n\nExample\n\njulia> using JuSwalbe, DelimitedFiles\n\njulia> args = [\"Lattice_points_x\" 10; \"Lattice_points_y\" 5; \"Max_run_time\" 1000; \"Output_dump\" 100; \"Relaxation_rate\" 1.0; \"gravity\" 0.0; \"surface_tension\" 0.01; \"slippage\" 1.0] # Generate a text file with input\n8×2 Array{Any,2}:\n \"Lattice_points_x\"    10\n \"Lattice_points_y\"     5\n \"Max_run_time\"      1000\n \"Output_dump\"        100\n \"Relaxation_rate\"      1.0\n \"gravity\"              0.0\n \"surface_tension\"      0.01\n \"slippage\"             1.0\n\njulia> writedlm(\"test.txt\", args)\n\njulia> test = readinput(\"test.txt\")\nJuSwalbe.Inputconstants\n  lx: Int64 10\n  ly: Int64 5\n  maxruntime: Int64 1000\n  dumping: Int64 100\n  τ: Float64 1.0\n  gravity: Float64 0.0\n  γ: Float64 0.01\n  δ: Float64 1.0\n  μ: Float64 0.16666666666666666\n\njulia> test.lx\n10\n\njulia> test.γ\n0.01\n\njulia> test.γ + test.δ\n1.01\n\njulia> isa(test.lx + test.gravity, Int32)\nfalse\n\njulia> rm(\"test.txt\")\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.streamdistperiodic!-Union{Tuple{JuSwalbe.DistributionD1Q3{Array{T,1}}}, Tuple{T}} where T<:Number","page":"Manual","title":"JuSwalbe.streamdistperiodic!","text":"streamdistperiodic!(dist)\n\nStreams the lattice Boltzmann distribution accoriding to their velocity vector.\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.Δh-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T<:Number","page":"Manual","title":"JuSwalbe.Δh","text":"Δh(mom::JuSwalbe.Macroquant)\n\nCalculates the laplacian of the height field with periodic boundaries.\n\nThe calculation of the laplacian is central for the thin film evolution. Only the pressure gradient will induce a flow, at least for the non-fluctuating version. Therefore it is fairly important to have an accurate computation of the laplacian.\n\nMath\n\nThe Laplace equation is given by \n\nDelta rho = 0\n\nThe laplace operator is simply Δ = ∇ . ∇.  Since the film pressure has a contribution Δh we need a discreticed laplace operator.\n\nTwo spatial dimensions\n\nIn two dimensions I follow the paper from Santosh and Succi. A nine-point stencil is used and the equation goes as follow\n\nDelta h_ij = frac164sum_nnh_ij + sum_diagh_ij - 20 h_ij\n\nWhere i and j are the x and y coordinates. The index nn relates to the nearest neighbors, all four elements which are exactly Δx away from (i,j). On the other hand the diagonal elements are those four which are have a distance √2Δx to (i,j).  Periodicity is taken care of by a circular padding of the height array. \n\nOne spatial dimension\n\nFor a single spatial dimension it is mostly sufficient to use the central difference approach. This approach is given by\n\n`` \\partialx^2 h{i} = h{i-1} - 2h{i} + h_{i+1}\n\nwith i being the index along the spatial dimension.\n\nExample\n\njulia> using JuSwalbe\n\njulia> height = reshape(collect(1.0:16.0), (4,4))\n4×4 Array{Float64,2}:\n 1.0  5.0   9.0  13.0\n 2.0  6.0  10.0  14.0\n 3.0  7.0  11.0  15.0\n 4.0  8.0  12.0  16.0\n\njulia> velx = zeros(Float64, (4,4))\n4×4 Array{Float64,2}:\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n\njulia> vely = zeros(Float64, (4,4))\n4×4 Array{Float64,2}:\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0\n \njulia> vel = JuSwalbe.Twovector(x=velx, y=vely)\nJuSwalbe.Twovector{Array{Float64,2}}\n  x: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]\n  y: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]\n\n\njulia> moment = JuSwalbe.Macroquant(height=height, velocity=vel, pressure=zeros(4,4), energy=zeros(4,4))\nJuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}\n  height: Array{Float64}((4, 4)) [1.0 5.0 9.0 13.0; 2.0 6.0 10.0 14.0; 3.0 7.0 11.0 15.0; 4.0 8.0 12.0 16.0]\n  velocity: JuSwalbe.Twovector{Array{Float64,2}}\n  pressure: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]\n  energy: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]\n\n\njulia> moment.height\n4×4 Array{Float64,2}:\n 1.0  5.0   9.0  13.0\n 2.0  6.0  10.0  14.0\n 3.0  7.0  11.0  15.0\n 4.0  8.0  12.0  16.0\n\njulia> laplace = Δh(moment)\n4×4 Array{Float64,2}:\n 20.0   4.0   4.0  -12.0\n 16.0   0.0   0.0  -16.0\n 16.0   0.0   0.0  -16.0\n 12.0  -4.0  -4.0  -20.0\n\njulia> height = collect(1.0:16.0)\n16-element Array{Float64,1}:\n  1.0\n  2.0\n  3.0\n  4.0\n  5.0\n  6.0\n  7.0\n  8.0\n  9.0\n 10.0\n 11.0\n 12.0\n 13.0\n 14.0\n 15.0\n 16.0\n\njulia> Δh(height)\n16-element Array{Float64,1}:\n  16.0\n   0.0\n   0.0\n   0.0\n   0.0\n   0.0\n   0.0\n   0.0\n   0.0\n   0.0\n   0.0\n   0.0\n   0.0\n   0.0\n   0.0\n -16.0\n\n\nReferences\n\nTwo spatial dimensions\n\nThere are plenty of papers concerning discret differentail operators. Many of them are good, although definitly not the best I go here with:\n\nIsotropic discrete Laplacian operators from lattice hydrodynamics\n\nOne spatial dimension\n\nAlmost any reference on discrete differentiation is good enough.\n\nNumerical Differentiation\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.Π-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T<:Number","page":"Manual","title":"JuSwalbe.Π","text":"Π(mom::JuSwalbe.Macroquant; h_star = 0.1, exponents = [9,3], γ = 0.01, θ = 1.0/9.0)\n\nCalculates the disjoining pressure for a given surface tension and contact angle at every lattice point.\n\nThe disjoing pressure potential enables the simulation to study phenomena like dewetting of thin liquid films. Only with this potential it is possible to \"dewett\" without using highly sophisticated boundary conditions at hrightarrow 0. The functional shape of this potential can vary, ranging from the powerlaw used here to exponentials to a mixture of both. Using the powerlaw shape the exponents (9,3) mimic the Lenard-Jones potential for the liquid substrate interaction.\n\nArguments\n\nmom::JuSwalbe.Macroquant : Macroscopic moments of the simulation, important here .height which contains the height field. Allows for array input as well.\nh_star::T : Minimum of the pontential. T needs to be a subtype of Number! \nexponents::Array{Int64,1} : Exponents for the powerlaw potential\nγ::T : Surface tension\nθ::T : Equilibrium contact angle in multiple of π (for accuarcy reasons). Needs to be an array when doing patterning. For simple substrate use a one entry array with correct dimension.\n\nMath\n\nThe potential can be derived from the assumption that a given surface energy demands an equilibrium contact angle for the fluid. For the exact derivation take a look at the references, in principle it is the derivative of the interfacial potential with respect to h.\n\nPhi(h) = Pi(h) \n\nPi(h) = kappa f(h) = (1-costheta)frac(n-1)(m-1)(n-m)h_astBiggBigg(frach_asthBigg)^n - Bigg(frach_asthBigg)^mBigg\n\nPi(h_ast) = 0 \n\nExample\n\njulia> using JuSwalbe\n\njulia> n,m = (4,4)\n(4, 4)\n\njulia> moment = JuSwalbe.Macroquant(height=ones(n,m), velocity=JuSwalbe.Twovector(x=zeros(n,m), y=zeros(n,m)), pressure=zeros(n,m), energy=zeros(n,m))\nJuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}\n  height: Array{Float64}((4, 4)) [1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0]\n  velocity: JuSwalbe.Twovector{Array{Float64,2}}\n  pressure: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]\n  energy: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]\n\njulia> p = Π(moment)\n4×4 Array{Float64,2}:\n -1.6082e-5  -1.6082e-5  -1.6082e-5  -1.6082e-5\n -1.6082e-5  -1.6082e-5  -1.6082e-5  -1.6082e-5\n -1.6082e-5  -1.6082e-5  -1.6082e-5  -1.6082e-5\n -1.6082e-5  -1.6082e-5  -1.6082e-5  -1.6082e-5\n\njulia> p = Π(moment, θ=zeros(1,1)) # Fully wetting substrate\n4×4 Array{Float64,2}:\n -0.0  -0.0  -0.0  -0.0\n -0.0  -0.0  -0.0  -0.0\n -0.0  -0.0  -0.0  -0.0\n -0.0  -0.0  -0.0  -0.0\n\njulia> h = reshape([i for i in 1.0:(n*m)],n,m)\n4×4 Array{Float64,2}:\n 1.0  5.0   9.0  13.0\n 2.0  6.0  10.0  14.0\n 3.0  7.0  11.0  15.0\n 4.0  8.0  12.0  16.0\n\njulia> p = Π(h)\n4×4 Array{Float64,2}:\n -1.6082e-5   -1.28656e-7  -2.20603e-8  -7.31997e-9\n -2.01025e-6  -7.44536e-8  -1.6082e-8   -5.86078e-9\n -5.95628e-7  -4.68862e-8  -1.20826e-8  -4.76503e-9\n -2.51281e-7  -3.14101e-8  -9.30669e-9  -3.92626e-9\n\n\nReferences\n\nTo get a good understanding:\n\nLong-scale evolution of thin liquid films\nWetting and spreading\nDynamics and stability of thin liquid films\n\nA rather recent new setup for the shape of Π can be found in \n\nSignatures of slip in dewetting polymer films \n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.∇p-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}}}} where T<:Number","page":"Manual","title":"JuSwalbe.∇p","text":"∇p(mom::JuSwalbe.Macroquant)\n\nComputation of the pressure gradient in one and two spatial dimensions.\n\nGiven a struct Macroquant with an .pressure entry performs a finite difference approximation of the spatial derivative. A five-point stencil is used for one spatial dimension. For two spatial dimensions a weighted nine-point stencil is applied. An perodicity around the edges is assumed (ring, torus).\n\nMath\n\nSince this is essentially discrete operators I will not go into details.\n\nTwo spatial dimensions\n\nnabla p = 3 sum_i=0^8 w_i mathbfc_i p(mathbfr+mathbfc_i) +O(nabla^3)\n\nWhere mathbfc_i w_i are the standard D2Q9 lattice velocities and weights. Of course this vector nabla p needs to be multiple with the height field to yield the correct force.\n\nOne spatial dimension\n\npartial_x p = fracp(x-2Delta x) - 8p(x-1Delta x) + 0p(x) + 8p(x+1Delta x) - p(x+2Delta x)12Delta x + O(partial_x^5)\n\nWhere the step size is limited by the resolution of the lattice Boltzmann grid Delta x.\n\nExample\n\nTwo spatial dimensions\n\njulia> using JuSwalbe\n\njulia> zerovelocity = JuSwalbe.Twovector(x=zeros(5,5), y=zeros(5,5)) # Thanks to @with_kw macro\nJuSwalbe.Twovector{Array{Float64,2}}\n  x: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  y: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n\njulia> mom = JuSwalbe.Macroquant(height=fill(1.0, (5,5)), velocity=zerovelocity, pressure=zerovelocity.x, energy=zerovelocity.y)\nJuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}\n  height: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]\n  velocity: JuSwalbe.Twovector{Array{Float64,2}}\n  pressure: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n  energy: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]\n\njulia> mom.height[2,3] = 2.0; mom.height[3,2] = 2.0; mom.height[4,3] = 2.0; mom.height[3,4] = 2.0\n2.0\n\njulia> p = pressure(mom)\n5×5 Array{Float64,2}:\n -1.6082e-5   -0.00168275  -0.00668275  -0.00168275  -1.6082e-5\n -0.00168275  -0.0133494    0.029998    -0.0133494   -0.00168275\n -0.00668275   0.029998    -0.0266827    0.029998    -0.00668275\n -0.00168275  -0.0133494    0.029998    -0.0133494   -0.00168275\n -1.6082e-5   -0.00168275  -0.00668275  -0.00168275  -1.6082e-5\n\njulia> mom.pressure\n5×5 Array{Float64,2}:\n -1.6082e-5   -0.00168275  -0.00668275  -0.00168275  -1.6082e-5\n -0.00168275  -0.0133494    0.029998    -0.0133494   -0.00168275\n -0.00668275   0.029998    -0.0266827    0.029998    -0.00668275\n -0.00168275  -0.0133494    0.029998    -0.0133494   -0.00168275\n -1.6082e-5   -0.00168275  -0.00668275  -0.00168275  -1.6082e-5\n\njulia> f = JuSwalbe.Forces(slip=zerovelocity, h∇p=zerovelocity, thermal=zerovelocity, bathymetry=zerovelocity)\nJuSwalbe.Forces{JuSwalbe.Twovector{Array{Float64,2}}}\n  slip: JuSwalbe.Twovector{Array{Float64,2}}\n  h∇p: JuSwalbe.Twovector{Array{Float64,2}}\n  bathymetry: JuSwalbe.Twovector{Array{Float64,2}}\n  thermal: JuSwalbe.Twovector{Array{Float64,2}}\n\njulia> gradp = ∇p(mom, f)\n5×5×2 Array{Float64,3}:\n[:, :, 1] =\n -0.00166667   -0.00097105   0.0102825   -0.00097105  -0.00166667\n -0.000137716   0.00833802  -0.00277309   0.00833802  -0.000137716\n  0.0           0.0          0.0          0.0          0.0\n  0.000137716  -0.00833802   0.00277309  -0.00833802   0.000137716\n  0.00166667    0.00097105  -0.0102825    0.00097105   0.00166667\n\n[:, :, 2] =\n -0.00166667  -0.000137716  0.0   0.000137716   0.00166667\n -0.00097105   0.00833802   0.0  -0.00833802    0.00097105\n  0.0102825   -0.00277309   0.0   0.00277309   -0.0102825\n -0.00097105   0.00833802   0.0  -0.00833802    0.00097105\n -0.00166667  -0.000137716  0.0   0.000137716   0.00166667\n\njulia> f.h∇p.x\n5×5 Array{Float64,2}:\n -0.00166667   -0.00097105   0.0102825   -0.00097105  -0.00166667\n -0.000137716   0.00833802  -0.00277309   0.00833802  -0.000137716\n  0.0           0.0          0.0          0.0          0.0\n  0.000137716  -0.00833802   0.00277309  -0.00833802   0.000137716\n  0.00166667    0.00097105  -0.0102825    0.00097105   0.00166667\n\njulia> f.h∇p.y\n5×5 Array{Float64,2}:\n -0.00166667  -0.000137716  0.0   0.000137716   0.00166667\n -0.00097105   0.00833802   0.0  -0.00833802    0.00097105\n  0.0102825   -0.00277309   0.0   0.00277309   -0.0102825\n -0.00097105   0.00833802   0.0  -0.00833802    0.00097105\n -0.00166667  -0.000137716  0.0   0.000137716   0.00166667\n \n\nOne spatial dimension\n\njulia> using JuSwalbe\n\njulia> mom = JuSwalbe.Macroquant(height=ones(10), velocity=zeros(10), pressure=zeros(10), energy=zeros(10))\nJuSwalbe.Macroquant{Array{Float64,1},Array{Float64,1}}\n  height: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  velocity: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  pressure: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  energy: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\njulia> f = JuSwalbe.Forces(slip=zeros(10), h∇p=zeros(10), thermal=zeros(10), bathymetry=zeros(10))\nJuSwalbe.Forces{Array{Float64,1}}\n  slip: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  h∇p: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  bathymetry: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  thermal: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\njulia> mom.height[4] = 0.5; mom.height[5] = 2.0; mom.height[6] = 0.5; \n\njulia> p = pressure(mom, θ=zeros(1), γ=1.0)\n10-element Array{Float64,1}:\n -0.0\n -0.0\n  0.5\n -2.0\n  3.0\n -2.0\n  0.5\n -0.0\n -0.0\n -0.0\n\njulia> gradp = ∇p(mom, f)\n10-element Array{Float64,1}:\n -0.041666666666666664\n  0.5\n -1.5833333333333333\n  0.9166666666666666\n  0.0\n -0.9166666666666666\n  1.5833333333333333\n -0.5\n  0.041666666666666664\n  0.0\n  \n\n\nReferences\n\nTwo spatial dimensions\n\nIsotropic discrete Laplacian operators from lattice hydrodynamics\nDiscretizations for the Incompressible Navier–Stokes Equations Based on the Lattice Boltzmann Method\n\nThe second reference is the older and more mathematically one, while the first reference is short and great for a fast look up.\n\nOne spatial dimension\n\nNumerical Differentiation\n\nAny lecture notes or book on discrete mathematics should do for the one dimensional case.\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.velocitysquared-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T<:Number","page":"Manual","title":"JuSwalbe.velocitysquared","text":"velocitysquared(mom::Macroquant{Matrix{T}, JuSwalbe.Twovector{Matrix{T}}})\n\nComputes the square of the velocity vector (ux, uy) at every lattice point.\n\nThe magnitude of the velocity is needed to calculate the equilibrium distribution in the dimensional case. In the one dimensional case the velocity is just a vector and therefore has no .x and .y component. See also calc_equilibrium_distribution\n\nMath\n\nThe velocity squared u^2(xy) is computed according to \n\nu^2(xy) = (u_x u_y)^2(xy) = u_x^2(xy) + u_y^2(xy)\n\nWith lower case x and y the respective component of the velocity vector is addressed.\n\nExample\n\njulia> using JuSwalbe\n\njulia> velocities = JuSwalbe.Twovector{Matrix{Float64}}(x=fill(0.1, (4,4)), y=fill(0.2, (4,4)))\nJuSwalbe.Twovector{Array{Float64,2}}\n  x: Array{Float64}((4, 4)) [0.1 0.1 0.1 0.1; 0.1 0.1 0.1 0.1; 0.1 0.1 0.1 0.1; 0.1 0.1 0.1 0.1]\n  y: Array{Float64}((4, 4)) [0.2 0.2 0.2 0.2; 0.2 0.2 0.2 0.2; 0.2 0.2 0.2 0.2; 0.2 0.2 0.2 0.2]\n\njulia> moment = JuSwalbe.Macroquant(height=ones(Float64, (4,4)), velocity=velocities, pressure=ones(Float64, (4,4)), energy=ones(Float64, (4,4)))\nJuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}\n  height: Array{Float64}((4, 4)) [1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0]\n  velocity: JuSwalbe.Twovector{Array{Float64,2}}\n  pressure: Array{Float64}((4, 4)) [1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0]\n  energy: Array{Float64}((4, 4)) [1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0]\n\njulia> moment.velocity.x\n4×4 Array{Float64,2}:\n 0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1\n 0.1  0.1  0.1  0.1\n\njulia> JuSwalbe.velocitysquared(moment)\n4×4 Array{Float64,2}:\n 0.05  0.05  0.05  0.05\n 0.05  0.05  0.05  0.05\n 0.05  0.05  0.05  0.05\n 0.05  0.05  0.05  0.05\n\n\n\n\n\n","category":"method"},{"location":"manual/#JuSwalbe.Inputconstants","page":"Manual","title":"JuSwalbe.Inputconstants","text":"Inputconstants = new(lx, ly, maxruntime, dumping, gravity, γ, δ)\n\nStruct containing input parameters.\n\nContains .lx lattice points in x-direction, .ly lattice points in y-direction.  Other fields are .maxruntime for the maximal number of time steps and .dumping to limit the number of output files. On top of these there are physical quantities such as .gravity, .γ and .δ  for the values of gravitational acceleration, fluids surface tension and the slip length. The example relates to an quadratic lattice 20 times 20 lattice units in area.  Run for 100 lattice Boltzmann time steps only printing output every 10 time steps. Having no gravity and a surface tension of 0.01 and a slip length of 1.  \n\nExample\n\njulia> using JuSwalbe\n\njulia> new_input = JuSwalbe.Inputconstants()\nJuSwalbe.Inputconstants\n  lx: Int64 512\n  ly: Int64 512\n  maxruntime: Int64 100000\n  dumping: Int64 1000\n  τ: Float64 1.0\n  gravity: Float64 0.0\n  γ: Float64 0.01\n  δ: Float64 1.0\n  μ: Float64 0.16666666666666666\n\njulia> new_input.γ\n0.01\n\nReferences\n\nSee also: readinput, findargument, computeslip\n\n\n\n\n\n","category":"type"},{"location":"manual/#JuSwalbe.inputfile","page":"Manual","title":"JuSwalbe.inputfile","text":"inputfile\n\nAbstract type for all kinds of input files\n\n\n\n\n\n","category":"type"},{"location":"reference/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"JuSwalbe is a package to simulate thin film flows with a lattice Boltzmann approach. The method is introduced in the paper: Lattice Boltzmann method for thin-liquid-film hydrodynamics.","category":"page"},{"location":"devnotes/#Developer-notes-1","page":"Developer notes","title":"Developer notes","text":"","category":"section"}]
}
