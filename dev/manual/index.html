<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · JuSwalbe.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JuSwalbe.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a></li><li><a class="tocitem" href="../reference/">References</a></li><li><a class="tocitem" href="../devnotes/">Developer notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/master/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual-1"><a class="docs-heading-anchor" href="#Manual-1">Manual</a><a class="docs-heading-anchor-permalink" href="#Manual-1" title="Permalink"></a></h1><p>Short and clean instructions how to use the Package. Functions and methods can be found here with usage examples.</p><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.calc_equilibrium_distribution-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number" href="#JuSwalbe.calc_equilibrium_distribution-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>JuSwalbe.calc_equilibrium_distribution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calc_equilibrium_distribution(mom::JuSwalbe.Macroquant; gravity=0)</code></pre><p>Calculates the equilibrium distributions based on the macroscopic quantities <code>mom</code> and gravitational acceleration <code>gravity</code>.</p><p>The equilibrium distribtutions are at the heart of the lattice Boltzmann method. As the expansion is made around the equilibrium, lattice Boltzmann always assumes that the flow field is close to equilibrium. Therefore the equilibrium is calculated from macroscopic quantities, i.e. height <code>.height</code> and velocity <code>.velocity</code>.</p><p><strong>Math:</strong></p><p><strong>One spatial dimension</strong></p><p>Defining equations in one spatial dimensions are expressed in the following way</p><p><span>$f_0^{eq} =  h - \frac{1}{2v^2}gh^2 - \frac{1}{v^2}hu^2$</span> </p><p><span>$f_1^{eq} =  \frac{1}{4v^2}gh^2 + \frac{1}{2v}hu + \frac{1}{2v^2}hu^2$</span></p><p><span>$f_2^{eq} =  \frac{1}{4v^2}gh^2 - \frac{1}{2v}hu + \frac{1}{2v^2}hu^2$</span></p><p><strong>Two spatial dimension</strong></p><p>In two spatial dimensions the velocity because a vector with a <code>x</code> and <code>y</code> component. Such the equations look a little more complex</p><p><span>$f_0^{eq} =  h - \frac{4}{9}h(\frac{15}{2}gh - \frac{3}{2}u^2)$</span></p><p><span>$f_i^{eq} = w_i h(\frac{3}{2}gh + 3 \mathbf{c}_i\cdot\mathbf{u} + \frac{9}{2}(\mathbf{c}_i\cdot\mathbf{u})^2 - \frac{3}{2}u^2))$</span></p><p>with i are the number of lattice speeds and w<em>i and c</em>i are the weights and sets of lattice velocities.</p><p><strong>Example</strong></p><p><strong>Two spatial dimensions</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; mom = JuSwalbe.Macroquant(height=ones(4,4), velocity=JuSwalbe.Twovector(x=fill(0.1, (4,4)), y=fill(-0.1, (4,4))), pressure=zeros(4,4), energy=zeros(4,4))
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((4, 4)) [1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]
  energy: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]

julia&gt; equilibrium = calc_equilibrium_distribution(mom)
JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((4, 4)) [0.9866666666666667 0.9866666666666667 0.9866666666666667 0.9866666666666667; 0.9866666666666667 0.9866666666666667 0.9866666666666667 0.9866666666666667; 0.9866666666666667 0.9866666666666667 0.9866666666666667 0.9866666666666667; 0.9866666666666667 0.9866666666666667 0.9866666666666667 0.9866666666666667]
  f1: Array{Float64}((4, 4)) [0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035]
  f2: Array{Float64}((4, 4)) [-0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667]
  f3: Array{Float64}((4, 4)) [-0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667; -0.03166666666666667 -0.03166666666666667 -0.03166666666666667 -0.03166666666666667]
  f4: Array{Float64}((4, 4)) [0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035; 0.035 0.035 0.035 0.035]
  f5: Array{Float64}((4, 4)) [-0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335]
  f6: Array{Float64}((4, 4)) [-0.0125 -0.0125 -0.0125 -0.0125; -0.0125 -0.0125 -0.0125 -0.0125; -0.0125 -0.0125 -0.0125 -0.0125; -0.0125 -0.0125 -0.0125 -0.0125]
  f7: Array{Float64}((4, 4)) [-0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335; -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335 -0.0008333333333333335]
  f8: Array{Float64}((4, 4)) [0.020833333333333336 0.020833333333333336 0.020833333333333336 0.020833333333333336; 0.020833333333333336 0.020833333333333336 0.020833333333333336 0.020833333333333336; 0.020833333333333336 0.020833333333333336 0.020833333333333336 0.020833333333333336; 0.020833333333333336 0.020833333333333336 0.020833333333333336 0.020833333333333336]

julia&gt; arr = dist2array(equilibrium)
9×4×4 Array{Float64,3}:
[:, :, 1] =
  0.986667      0.986667      0.986667      0.986667
  0.035         0.035         0.035         0.035
 -0.0316667    -0.0316667    -0.0316667    -0.0316667
 -0.0316667    -0.0316667    -0.0316667    -0.0316667
  0.035         0.035         0.035         0.035
 -0.000833333  -0.000833333  -0.000833333  -0.000833333
 -0.0125       -0.0125       -0.0125       -0.0125
 -0.000833333  -0.000833333  -0.000833333  -0.000833333
  0.0208333     0.0208333     0.0208333     0.0208333

[:, :, 2] =
  0.986667      0.986667      0.986667      0.986667
  0.035         0.035         0.035         0.035
 -0.0316667    -0.0316667    -0.0316667    -0.0316667
 -0.0316667    -0.0316667    -0.0316667    -0.0316667
  0.035         0.035         0.035         0.035
 -0.000833333  -0.000833333  -0.000833333  -0.000833333
 -0.0125       -0.0125       -0.0125       -0.0125
 -0.000833333  -0.000833333  -0.000833333  -0.000833333
  0.0208333     0.0208333     0.0208333     0.0208333

[:, :, 3] =
  0.986667      0.986667      0.986667      0.986667
  0.035         0.035         0.035         0.035
 -0.0316667    -0.0316667    -0.0316667    -0.0316667
 -0.0316667    -0.0316667    -0.0316667    -0.0316667
  0.035         0.035         0.035         0.035
 -0.000833333  -0.000833333  -0.000833333  -0.000833333
 -0.0125       -0.0125       -0.0125       -0.0125
 -0.000833333  -0.000833333  -0.000833333  -0.000833333
  0.0208333     0.0208333     0.0208333     0.0208333

[:, :, 4] =
  0.986667      0.986667      0.986667      0.986667
  0.035         0.035         0.035         0.035
 -0.0316667    -0.0316667    -0.0316667    -0.0316667
 -0.0316667    -0.0316667    -0.0316667    -0.0316667
  0.035         0.035         0.035         0.035
 -0.000833333  -0.000833333  -0.000833333  -0.000833333
 -0.0125       -0.0125       -0.0125       -0.0125
 -0.000833333  -0.000833333  -0.000833333  -0.000833333
  0.0208333     0.0208333     0.0208333     0.0208333

julia&gt; h = sum(arr, dims=1)[1,:,:] # Check consistency 
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
</code></pre><p><strong>One spatial dimension</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; mom = JuSwalbe.Macroquant(height=ones(5), velocity=fill(0.1, 5), pressure=zeros(5), energy=zeros(5))
JuSwalbe.Macroquant{Array{Float64,1},Array{Float64,1}}
  height: Array{Float64}((5,)) [1.0, 1.0, 1.0, 1.0, 1.0]
  velocity: Array{Float64}((5,)) [0.1, 0.1, 0.1, 0.1, 0.1]
  pressure: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]
  energy: Array{Float64}((5,)) [0.0, 0.0, 0.0, 0.0, 0.0]

julia&gt; equilibrium = calc_equilibrium_distribution(mom)
JuSwalbe.DistributionD1Q3{Array{Float64,1}}
  f0: Array{Float64}((5,)) [0.99, 0.99, 0.99, 0.99, 0.99]
  f1: Array{Float64}((5,)) [0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001]
  f2: Array{Float64}((5,)) [-0.045, -0.045, -0.045, -0.045, -0.045]

julia&gt; h = sum(hcat(equilibrium.f0, equilibrium.f1, equilibrium.f2), dims=2)[:,1]
5-element Array{Float64,1}:
 0.9999999999999999
 0.9999999999999999
 0.9999999999999999
 0.9999999999999999
 0.9999999999999999

julia&gt; h[1] - 1.0 # fits up to machine precision
-1.1102230246251565e-16
</code></pre><p><strong>References</strong></p><p><strong>Code</strong></p><p>See also: <a href="#JuSwalbe.velocitysquared-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number"><code>velocitysquared</code></a></p><p><strong>One spatial dimension</strong></p><p>There are plenty of ways to calculate them I mainly the ones derived in Eq.(13) of <a href="https://www.sciencedirect.com/science/article/pii/S0021999110003372">Study of the 1D lattice Boltzmann shallow water equation and its coupling to build a canal network.</a></p><p><strong>Two spatial dimensions</strong></p><p>Here I stick to the paper written by Paul Dellar, Eq.(26) of <a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.65.036309">Nonhydrodynamic modes and <em>a priori</em> construction of shallow water lattice Boltzmann equations</a> Originally these equilibria have been worked out by Paul Salmon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/equilibriumcalculation.jl#L1-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.calculatemoments-Union{Tuple{JuSwalbe.DistributionD1Q3{Array{T,1}}}, Tuple{T}} where T&lt;:Number" href="#JuSwalbe.calculatemoments-Union{Tuple{JuSwalbe.DistributionD1Q3{Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>JuSwalbe.calculatemoments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">calculatemoments(dist)</code></pre><p>Computes the lattice Boltzmann moments (h,v) from a distribution function <code>dist</code>.</p><p>Based on the input either a <code>D1Q3</code> or a <code>D2Q9</code> distribution this function performs a summation over the particle speeds. In one spatial dimension the velocity set [-1, 0, 1] allows for three speeds in two for nine speeds. See also: <a href="#JuSwalbe.dist2array-Union{Tuple{JuSwalbe.DistributionD2Q9{Array{T,2}}}, Tuple{T}} where T&lt;:Number"><code>dist2array</code></a></p><p><strong>Math</strong></p><p>The moments are calculated according to </p><p><span>$\rho = \sum_{i=0}^N f_i$</span></p><p><span>$\rho\mathbf{u} = \sum_{i=0}^N \mathbf{c}_i f_i$</span></p><p><span>$e = \sum_{i=0}^N \mathbf{c}_i \mathbf{c}_i f_i$</span></p><p>Where N is either 3 or 9. In one spatial dimension the velocity is of course not a vector of <span>$(x,y)$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; a = fill(0.1, (10, 10))
10×10 Array{Float64,2}:
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1

julia&gt; b = fill(0.2, (10,10))
10×10 Array{Float64,2}:
 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2  0.2

julia&gt; dist = JuSwalbe.DistributionD2Q9(f0=a,f1=b,f2=a,f3=a,f4=a,f5=a,f6=a,f7=a,f8=a)
JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f1: Array{Float64}((10, 10)) [0.2 0.2 … 0.2 0.2; 0.2 0.2 … 0.2 0.2; … ; 0.2 0.2 … 0.2 0.2; 0.2 0.2 … 0.2 0.2]
  f2: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f3: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f4: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f5: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f6: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f7: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f8: Array{Float64}((10, 10)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]

julia&gt; mom = calculatemoments(dist)
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((10, 10)) [0.9999999999999999 0.9999999999999999 … 0.9999999999999999 0.9999999999999999; 0.9999999999999999 0.9999999999999999 … 0.9999999999999999 0.9999999999999999; … ; 0.9999999999999999 0.9999999999999999 … 0.9999999999999999 0.9999999999999999; 0.9999999999999999 0.9999999999999999 … 0.9999999999999999 0.9999999999999999]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((10, 10)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  energy: Array{Float64}((10, 10)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; mom.height
10×10 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0  1.0

julia&gt; mom.velocity.x
10×10 Array{Float64,2}:
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1  0.1

julia&gt; mom.velocity.y
10×10 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0

julia&gt; dist1d = JuSwalbe.DistributionD1Q3(f0=a[1:10],f1=b[1:10],f2=a[1:10]) # Vectorize a and b
JuSwalbe.DistributionD1Q3{Array{Float64,1}}
  f0: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
  f1: Array{Float64}((10,)) [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]
  f2: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]

julia&gt; mom1d = calculatemoments(dist1d)
JuSwalbe.Macroquant{Array{Float64,1},Array{Float64,1}}
  height: Array{Float64}((10,)) [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4]
  velocity: Array{Float64}((10,)) [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]
  pressure: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  energy: Array{Float64}((10,)) [0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004, 0.30000000000000004]

julia&gt; mom1d.height
10-element Array{Float64,1}:
 0.4
 0.4
 0.4
 0.4
 0.4
 0.4
 0.4
 0.4
 0.4
 0.4


julia&gt; mom1d.velocity
10-element Array{Float64,1}:
 0.25
 0.25
 0.25
 0.25
 0.25
 0.25
 0.25
 0.25
 0.25
 0.25
</code></pre><p><strong>References</strong></p><p><strong>Code</strong></p><p>See also: <a href="#JuSwalbe.dist2array-Union{Tuple{JuSwalbe.DistributionD2Q9{Array{T,2}}}, Tuple{T}} where T&lt;:Number"><code>dist2array</code></a></p><p><strong>Two spatial dimensions</strong></p><p>Here I go with Dellar</p><ul><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.65.036309">Nonhydrodynamic modes and <em>a priori</em> construction of shallow water lattice Boltzmann equations</a></li></ul><p><strong>One spatial dimension</strong></p><p>For the one dimensional simulation the paper by Chopard is quite nice</p><ul><li><a href="https://www.sciencedirect.com/science/article/pii/S0021999110003372">Study of the 1D lattice Boltzmann shallow water equation and its coupling to build a canal network.</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/calcmoments.jl#L1-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.collisionBGK-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}},JuSwalbe.DistributionD1Q3{Array{T,1}},JuSwalbe.Inputconstants}} where T&lt;:Number" href="#JuSwalbe.collisionBGK-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}},JuSwalbe.DistributionD1Q3{Array{T,1}},JuSwalbe.Inputconstants}} where T&lt;:Number"><code>JuSwalbe.collisionBGK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collisionBGK(mom, tempdist, input)</code></pre><p>Computes the BGK collision operation for a <code>D1Q3</code> and a <code>D2Q9</code> lattice Boltzmann algorithm.</p><p>The collision operator is the central object in kinetic theory.  However there is no general solution for this operator.  One work around is to make assumptions and try to model them.  The BGK operator is one of the fairly successful operators.  It stems from the idea that the distributions are close to their equilibria and that all of them <em>relax</em> with a single relaxation time <code>τ</code>.</p><p><strong>Math</strong></p><p>The collision operator is usually the right hand side of the kinetic equation </p><p><span>$\partial_t f + \frac{\mathbf{p}}{m}\cdot\nabla f + \mathbf{F}\cdot \partial_{\mathbf{p}} f = \Omega .$</span></p><p>After tedious mathematics and expansions one can obtain the simplest collision operator the BGK as</p><p><span>$\Omega_{BGK} = -\frac{f - f^{eq}}{\tau},$</span></p><p>with <code>τ</code> being the relaxation parameter.  Such the collision process in the lattice Boltzmann method tries to equilibrate the system.</p><p>If there is an additional force acting on the fluid, i.e. <code>gravity</code> than this part is usually included in the numerical implementation of the collision operator. The forcing vector of source term is often called <span>$\mathbf{S}_{\alpha}$</span> and given by</p><p><span>$\mathbf{S}_{\alpha} = \Delta t \frac{3 w_{\alpha}}{\mathvbf{c}_{\alpha}^2}\mathbf{c}_{\alpha,i} \mathbf{F}_i.$</span></p><p><strong>Example</strong></p><p><strong>One spatial dimension</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; input, mom, force, dist = minimalsetup1d(10)
(JuSwalbe.Inputconstants
  lx: Int64 10
  ly: Int64 512
  maxruntime: Int64 100000
  dumping: Int64 1000
  τ: Float64 1.0
  gravity: Float64 0.0
  γ: Float64 0.01
  δ: Float64 1.0
  μ: Float64 0.16666666666666666
, JuSwalbe.Macroquant{Array{Float64,1},Array{Float64,1}}
  height: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
  velocity: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
  pressure: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  energy: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
, JuSwalbe.Forces{Array{Float64,1}}
  slip: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
  h∇p: Array{Float64}((10,)) [-0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1]
  bathymetry: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  thermal: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
, JuSwalbe.DistributionD1Q3{Array{Float64,1}}
  f0: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
  f1: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  f2: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
)

julia&gt; force.slip = zeros(10)
10-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0

julia&gt; force.h∇p = zeros(10)
10-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0

julia&gt; newdist = collisionBGK(mom, force, dist, input)
JuSwalbe.DistributionD1Q3{Array{Float64,1}}
  f0: Array{Float64}((10,)) [0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99]
  f1: Array{Float64}((10,)) [0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001]
  f2: Array{Float64}((10,)) [-0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045]

julia&gt; equi = calc_equilibrium_distribution(mom, gravity=input.gravity)
JuSwalbe.DistributionD1Q3{Array{Float64,1}}
  f0: Array{Float64}((10,)) [0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99]
  f1: Array{Float64}((10,)) [0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001, 0.05500000000000001]
  f2: Array{Float64}((10,)) [-0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045, -0.045]

julia&gt; using Test; @test equi.f0 == newdist.f0 # without forces and τ = 1 they have to be equal
Test Passed</code></pre><p><strong>Two spatial dimensions</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe, Test

julia&gt; input, mom, force, dist = minimalsetup2d(10,5)
(JuSwalbe.Inputconstants
  lx: Int64 10
  ly: Int64 5
  maxruntime: Int64 100000
  dumping: Int64 1000
  τ: Float64 1.0
  gravity: Float64 0.0
  γ: Float64 0.01
  δ: Float64 1.0
  μ: Float64 0.16666666666666666
, JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((10, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  energy: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
, JuSwalbe.Forces{JuSwalbe.Twovector{Array{Float64,2}}}
  slip: JuSwalbe.Twovector{Array{Float64,2}}
  h∇p: JuSwalbe.Twovector{Array{Float64,2}}
  bathymetry: JuSwalbe.Twovector{Array{Float64,2}}
  thermal: JuSwalbe.Twovector{Array{Float64,2}}
, JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((10, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  f1: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f2: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f3: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f4: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f5: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f6: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f7: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f8: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
)

julia&gt; dist
JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((10, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  f1: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f2: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f3: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f4: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f5: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f6: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f7: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f8: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; equi = calc_equilibrium_distribution(mom, gravity=input.gravity)
JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((10, 5)) [0.9994666666666666 0.9994666666666666 … 0.9994666666666666 0.9994666666666666; 0.9994666666666666 0.9994666666666666 … 0.9994666666666666 0.9994666666666666; … ; 0.9994666666666666 0.9994666666666666 … 0.9994666666666666 0.9994666666666666; 0.9994666666666666 0.9994666666666666 … 0.9994666666666666 0.9994666666666666]
  f1: Array{Float64}((10, 5)) [0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; … ; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333]
  f2: Array{Float64}((10, 5)) [-0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; … ; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999]
  f3: Array{Float64}((10, 5)) [-0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; … ; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999]
  f4: Array{Float64}((10, 5)) [0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; … ; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333]
  f5: Array{Float64}((10, 5)) [-3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; … ; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5]
  f6: Array{Float64}((10, 5)) [-0.0031666666666666666 -0.0031666666666666666 … -0.0031666666666666666 -0.0031666666666666666; -0.0031666666666666666 -0.0031666666666666666 … -0.0031666666666666666 -0.0031666666666666666; … ; -0.0031666666666666666 -0.0031666666666666666 … -0.0031666666666666666 -0.0031666666666666666; -0.0031666666666666666 -0.0031666666666666666 … -0.0031666666666666666 -0.0031666666666666666]
  f7: Array{Float64}((10, 5)) [-3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; … ; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5]
  f8: Array{Float64}((10, 5)) [0.0034999999999999996 0.0034999999999999996 … 0.0034999999999999996 0.0034999999999999996; 0.0034999999999999996 0.0034999999999999996 … 0.0034999999999999996 0.0034999999999999996; … ; 0.0034999999999999996 0.0034999999999999996 … 0.0034999999999999996 0.0034999999999999996; 0.0034999999999999996 0.0034999999999999996 … 0.0034999999999999996 0.0034999999999999996]

julia&gt; force.slip = JuSwalbe.Twovector(x=zeros(10,5), y=zeros(10,5))
JuSwalbe.Twovector{Array{Float64,2}}
  x: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  y: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; force.h∇p = JuSwalbe.Twovector(x=zeros(10,5), y=zeros(10,5))
JuSwalbe.Twovector{Array{Float64,2}}
  x: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  y: Array{Float64}((10, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; newdist = collisionBGK(mom, force, dist, input)
JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((10, 5)) [0.9994666666666666 0.9994666666666666 … 0.9994666666666666 0.9994666666666666; 0.9994666666666666 0.9994666666666666 … 0.9994666666666666 0.9994666666666666; … ; 0.9994666666666666 0.9994666666666666 … 0.9994666666666666 0.9994666666666666; 0.9994666666666666 0.9994666666666666 … 0.9994666666666666 0.9994666666666666]
  f1: Array{Float64}((10, 5)) [0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; … ; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333]
  f2: Array{Float64}((10, 5)) [-0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; … ; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999]
  f3: Array{Float64}((10, 5)) [-0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; … ; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999; -0.006599999999999999 -0.006599999999999999 … -0.006599999999999999 -0.006599999999999999]
  f4: Array{Float64}((10, 5)) [0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; … ; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333; 0.006733333333333333 0.006733333333333333 … 0.006733333333333333 0.006733333333333333]
  f5: Array{Float64}((10, 5)) [-3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; … ; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5]
  f6: Array{Float64}((10, 5)) [-0.0031666666666666666 -0.0031666666666666666 … -0.0031666666666666666 -0.0031666666666666666; -0.0031666666666666666 -0.0031666666666666666 … -0.0031666666666666666 -0.0031666666666666666; … ; -0.0031666666666666666 -0.0031666666666666666 … -0.0031666666666666666 -0.0031666666666666666; -0.0031666666666666666 -0.0031666666666666666 … -0.0031666666666666666 -0.0031666666666666666]
  f7: Array{Float64}((10, 5)) [-3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; … ; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5; -3.3333333333333335e-5 -3.3333333333333335e-5 … -3.3333333333333335e-5 -3.3333333333333335e-5]
  f8: Array{Float64}((10, 5)) [0.0034999999999999996 0.0034999999999999996 … 0.0034999999999999996 0.0034999999999999996; 0.0034999999999999996 0.0034999999999999996 … 0.0034999999999999996 0.0034999999999999996; … ; 0.0034999999999999996 0.0034999999999999996 … 0.0034999999999999996 0.0034999999999999996; 0.0034999999999999996 0.0034999999999999996 … 0.0034999999999999996 0.0034999999999999996]

julia&gt; @test equi.f0 == newdist.f0 # No force and τ=1 means fnew has to be feq!
Test Passed

julia&gt; @test equi.f2 == newdist.f2
Test Passed</code></pre><p><strong>References</strong></p><p>In general a very good reference concerning the method at all is the book written by Timm Krüger -<a href="https://www.springer.com/gp/book/9783319446479">The Lattice Boltzmann Method: Principles and Practice</a></p><p><strong>One spatial dimension</strong></p><p>Here is the work by Chopard et al. really worth reading</p><ul><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S0045793013003599">Asymmetric lattice Boltzmann model for shallow water flows</a></li></ul><p><strong>Two spatial dimensions</strong></p><p>In two dimensions there is the problematic of how to add forces. One way to justify is to do a Chapman Enskog expansion and match the shallow water equations with a source term. Apparently there is not a unique solution but a class of possible forcings. The first approach by Salmon does not include the lattice weights, which results in isotropy problems. On the other hand Zhous approach is not as acqurate as he says, which was pointed out by Chopard. Nevertheless here are some references educate yourself which is the fitting one -<a href="https://www.ingentaconnect.com/content/jmr/jmr/1999/00000057/00000003/art00005">The lattice Boltzmann method as a basis for ocean circulation modeling, by Salmon</a> -<a href="https://www.springer.com/gp/book/9783540407461">Lattice Boltzmann Methods for Shallow Water Flows, by Zhou</a> -<a href="https://onlinelibrary.wiley.com/doi/pdf/10.1002/fld.4726">An evaluation of force terms in the lattice Boltzmann models in simulating shallow water flows over complex topography, by Peng</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/collide.jl#L1-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.computeslip-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}},JuSwalbe.Inputconstants}} where T&lt;:Number" href="#JuSwalbe.computeslip-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}},JuSwalbe.Inputconstants}} where T&lt;:Number"><code>JuSwalbe.computeslip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">computeslip(mom, δ, force)</code></pre><p>Calculates the force due to slippage on the substrate.</p><p>Since the model only alows for forces in <code>x</code> and <code>y</code> direction but not in <code>z</code> it is necessary to regularize the velocity at <span>$h \rightarrow 0$</span>. The so called no-slip boundary condition can be in theory implemented using <code>δ</code> = 0.  However as soon as the film dewets and <code>height</code> becomes small, the solution diverges. Choosing <code>δ</code> = 1 satisfies the weak slip condition, while choosing it much larger than 1 yields the strong slip solution.</p><p><strong>Math</strong></p><p>One and two dimensional approaches are essentially equal. Behind the force is the idea of a parabolic shape of the velocity along <code>z</code>. With the boundary conditions</p><p><span>$\mathbf{u}|_{h=H} = \mathbf{u}$</span></p><p><span>$\mathbf{u}|_{h=0} = 0$</span></p><p>The parameter <code>δ</code> allows to push the zero velocity into the substrate, such below te computable region. Solving this equation with some more assumptions yields</p><p><span>$\mathbf{F}_{slip} = \mu\alpha_{\delta}(h) \mathbf{u} = \frac{6\mu h \mathbf{u}}{2 h^2 + 6\delta h + 3\delta^2}.$</span></p><p><strong>Example</strong></p><p><strong>References</strong></p><p>Here I shamelessly cite the paper from within our group </p><ul><li><a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.100.033313">Lattice Boltzmann method for thin-liquid-film hydrodynamics</a></li></ul><p>See also: <a href="#JuSwalbe.Inputconstants"><code>Inputconstants</code></a>, <a href="#JuSwalbe.calculatemoments-Union{Tuple{JuSwalbe.DistributionD1Q3{Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>calculatemoments</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/forcing.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.dist2array-Union{Tuple{JuSwalbe.DistributionD2Q9{Array{T,2}}}, Tuple{T}} where T&lt;:Number" href="#JuSwalbe.dist2array-Union{Tuple{JuSwalbe.DistributionD2Q9{Array{T,2}}}, Tuple{T}} where T&lt;:Number"><code>JuSwalbe.dist2array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dist2array(dist)</code></pre><p>Transforms the <code>D2Q9</code> struct into a three dimensional array.</p><p>Axis are chosen such that it can be easily multiplied with the nine speed lattice speeds. The function also excepts a <code>Forces</code> struct as input and returns a three dimensional array for both <code>x</code> and <code>y</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; a = fill(0.1, (5,5))
5×5 Array{Float64,2}:
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1

julia&gt; b = fill(0.2, (5,5))
5×5 Array{Float64,2}:
 0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2
 0.2  0.2  0.2  0.2  0.2

julia&gt; dist = JuSwalbe.DistributionD2Q9(f0=a, f1=b, f2=a, f3=a, f4=a, f5=a, f6=a, f7=a, f8=a)
JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f1: Array{Float64}((5, 5)) [0.2 0.2 … 0.2 0.2; 0.2 0.2 … 0.2 0.2; … ; 0.2 0.2 … 0.2 0.2; 0.2 0.2 … 0.2 0.2]
  f2: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f3: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f4: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f5: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f6: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f7: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f8: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]

julia&gt; arr = dist2array(dist)
9×5×5 Array{Float64,3}:
[:, :, 1] =
 0.1  0.1  0.1  0.1  0.1
 0.2  0.2  0.2  0.2  0.2
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1

[:, :, 2] =
 0.1  0.1  0.1  0.1  0.1
 0.2  0.2  0.2  0.2  0.2
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1

[:, :, 3] =
 0.1  0.1  0.1  0.1  0.1
 0.2  0.2  0.2  0.2  0.2
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1

[:, :, 4] =
 0.1  0.1  0.1  0.1  0.1
 0.2  0.2  0.2  0.2  0.2
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1

[:, :, 5] =
 0.1  0.1  0.1  0.1  0.1
 0.2  0.2  0.2  0.2  0.2
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/calcmoments.jl#L271-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.findargument-Tuple{Array{Any,2},String}" href="#JuSwalbe.findargument-Tuple{Array{Any,2},String}"><code>JuSwalbe.findargument</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findargument(arr, str)</code></pre><p>Searches for a numerical value based on a str input and returns the value.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; arr = [&quot;hmm&quot; 1; &quot;yeah&quot; 0.01; &quot;world&quot; 1090]
3×2 Array{Any,2}:
 &quot;hmm&quot;       1
 &quot;yeah&quot;      0.01
 &quot;world&quot;  1090

julia&gt; world = findargument(arr, &quot;world&quot;)
1090
</code></pre><p><strong>References</strong></p><p>See also: <a href="#JuSwalbe.readinput-Tuple{Any}"><code>readinput</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/readinput.jl#L143-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.height2file-Tuple{JuSwalbe.Macroscopic_quantity}" href="#JuSwalbe.height2file-Tuple{JuSwalbe.Macroscopic_quantity}"><code>JuSwalbe.height2file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">height2file(mom, name, time)</code></pre><p>Saves the heightfield to a file in a binary format.</p><p>For data purposes and reproducibility one can save the heightfield to a file. Such the file can be accessed with another software for e.g. post processing.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe, BSON

julia&gt; mom = JuSwalbe.Macroquant(height = ones(5,5), velocity=JuSwalbe.Twovector(x=zeros(5,5), y=zeros(5,5)), pressure=zeros(5,5), energy=zeros(5,5))
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  energy: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; height2file(mom)

julia&gt; h = BSON.load(&quot;data/tmp/height_0.bson&quot;)
Dict{Symbol,Any} with 1 entry:
  :height =&gt; [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 …

julia&gt; h[:height]
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0

julia&gt; mom.height == h[:height]
true

julia&gt; rm(&quot;data/tmp/height_0.bson&quot;)
</code></pre><p>See also: <a href="#JuSwalbe.savecheckpoint-Tuple{JuSwalbe.Distributionfunction}"><code>savecheckpoint</code></a>, <a href="#JuSwalbe.velocity2file-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>velocity2file</code></a>, <a href="#JuSwalbe.velocityandheight2file-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>velocityandheight2file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/readwritedata.jl#L102-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.loadcheckpoint-Tuple{Any}" href="#JuSwalbe.loadcheckpoint-Tuple{Any}"><code>JuSwalbe.loadcheckpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadcheckpoint(file)</code></pre><p>Loads a checkpoint file and generates a distribution function from it.</p><p>With the distribution function one can rerun a simulation from the point where the distribution function was saved. This is helpful for the long runs, when it takes several hours to generate convergence. Such it is adviced to generate a checkpoint roughly every three hours.</p><p><strong>Example</strong></p><p>For an example see <code>savecheckpoint</code>.</p><p>See also: <a href="#JuSwalbe.savecheckpoint-Tuple{JuSwalbe.Distributionfunction}"><code>savecheckpoint</code></a>, <a href="#JuSwalbe.savecheckpoints-Tuple{JuSwalbe.Distributionfunction}"><code>savecheckpoints</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/readwritedata.jl#L72-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.minimalsetup1d-Tuple{Int64}" href="#JuSwalbe.minimalsetup1d-Tuple{Int64}"><code>JuSwalbe.minimalsetup1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimalsetup1d(N)</code></pre><p>Creates a minimal setup of all important variables.</p><p>Such it generates the moments <code>height</code>, <code>velocity</code> as well as a dummy distribution with its speeds <code>f0</code>, <code>f1</code> and <code>f2</code>. Further a set of forcing is supplied, they can be used with <code>foces.slip</code>, <code>.h∇p</code>, <code>.bathymetry</code> and <code>.thermal</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; constants, mom, f, distribution = minimalsetup1d(10)
(JuSwalbe.Inputconstants
  lx: Int64 10
  ly: Int64 512
  maxruntime: Int64 100000
  dumping: Int64 1000
  τ: Float64 1.0
  gravity: Float64 0.0
  γ: Float64 0.01
  δ: Float64 1.0
  μ: Float64 0.16666666666666666
, JuSwalbe.Macroquant{Array{Float64,1},Array{Float64,1}}
  height: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
  velocity: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
  pressure: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  energy: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
, JuSwalbe.Forces{Array{Float64,1}}
  slip: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
  h∇p: Array{Float64}((10,)) [-0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1]
  bathymetry: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  thermal: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
, JuSwalbe.DistributionD1Q3{Array{Float64,1}}
  f0: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
  f1: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  f2: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
)

julia&gt; mom.height
10-element Array{Float64,1}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0</code></pre><p>See also: <a href="#JuSwalbe.minimalsetup2d-Tuple{Int64,Int64}"><code>minimalsetup2d</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/minimalsetup.jl#L1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.minimalsetup2d-Tuple{Int64,Int64}" href="#JuSwalbe.minimalsetup2d-Tuple{Int64,Int64}"><code>JuSwalbe.minimalsetup2d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimalsetup2d(N,M)</code></pre><p>Creates a minimal working example set of macroscopic moments, forces and a distribution.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; input, mom, f, dist = minimalsetup2d(5,5)
(JuSwalbe.Inputconstants
  lx: Int64 5
  ly: Int64 5
  maxruntime: Int64 100000
  dumping: Int64 1000
  τ: Float64 1.0
  gravity: Float64 0.0
  γ: Float64 0.01
  δ: Float64 1.0
  μ: Float64 0.16666666666666666
, JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  energy: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
, JuSwalbe.Forces{JuSwalbe.Twovector{Array{Float64,2}}}
  slip: JuSwalbe.Twovector{Array{Float64,2}}
  h∇p: JuSwalbe.Twovector{Array{Float64,2}}
  bathymetry: JuSwalbe.Twovector{Array{Float64,2}}
  thermal: JuSwalbe.Twovector{Array{Float64,2}}
, JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  f1: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f2: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f3: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f4: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f5: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f6: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f7: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f8: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
)
</code></pre><p>See also: <a href="#JuSwalbe.minimalsetup1d-Tuple{Int64}"><code>minimalsetup1d</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/minimalsetup.jl#L63-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.pressure-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number" href="#JuSwalbe.pressure-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number"><code>JuSwalbe.pressure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pressure(mom::JuSwalbe.Macroquant; γ = 0.01, θ = 1/9)</code></pre><p>Film pressure of the thin film equation.</p><p>This is just the summation of the laplacian of the height <code>Δh</code> and the disjoining potential <code>Π</code>. Since this function uses Π one has to be careful of θ as it should be an array. However it can be either a single element array or as large as the whole domain. See also: <a href="#JuSwalbe.Δh-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number"><code>Δh</code></a>, <a href="#JuSwalbe.Π-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number"><code>Π</code></a></p><p><strong>Math</strong></p><p>The film pressure is simply</p><p><span>$p_{film} = -\gamma\Delta h + \Pi(h)$</span></p><p>The sign is not 100% fixed and can change from paper to paper. Here I choose to be in agreement with Thiele et al., which is known to be a good theoretician. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; height = reshape([i for i in 1.0:1.0:16.0],4,4)
4×4 Array{Float64,2}:
 1.0  5.0   9.0  13.0
 2.0  6.0  10.0  14.0
 3.0  7.0  11.0  15.0
 4.0  8.0  12.0  16.0

julia&gt; p = pressure(height)
4×4 Array{Float64,2}:
 -0.200016  -0.0400001   -0.04        0.12
 -0.160002  -7.44536e-8  -1.6082e-8   0.16
 -0.160001  -4.68862e-8  -1.20826e-8  0.16
 -0.12       0.04         0.04        0.2

julia&gt; mom = JuSwalbe.Macroquant(height=height, velocity=JuSwalbe.Twovector(x=zeros(4,4), y=zeros(4,4)), pressure=zeros(4,4), energy=zeros(4,4))
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((4, 4)) [1.0 5.0 9.0 13.0; 2.0 6.0 10.0 14.0; 3.0 7.0 11.0 15.0; 4.0 8.0 12.0 16.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]
  energy: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]

julia&gt; mom.pressure
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia&gt; pressure(mom) # Pressure is stored in the moments struct!
4×4 Array{Float64,2}:
 -0.200016  -0.0400001   -0.04        0.12
 -0.160002  -7.44536e-8  -1.6082e-8   0.16
 -0.160001  -4.68862e-8  -1.20826e-8  0.16
 -0.12       0.04         0.04        0.2

julia&gt; mom.pressure
4×4 Array{Float64,2}:
 -0.200016  -0.0400001   -0.04        0.12
 -0.160002  -7.44536e-8  -1.6082e-8   0.16
 -0.160001  -4.68862e-8  -1.20826e-8  0.16
 -0.12       0.04         0.04        0.2
</code></pre><p>So what does this mean? A positive pressure is force that drives the film down in height. While a negative pressure generates a flux towards that location. In the example a linear increasing height field was used, an equilibrium though is reached when the film is flat.</p><p><strong>References</strong></p><p><strong>Recent (short)</strong></p><ul><li><a href="https://www.pnas.org/content/116/19/9275">Signatures of slip in dewetting polymer films</a></li></ul><p><strong>Review</strong></p><ul><li><a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.81.1131">Dynamics and stability of thin liquid films</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/calculatepressure.jl#L1-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.readinput-Tuple{Any}" href="#JuSwalbe.readinput-Tuple{Any}"><code>JuSwalbe.readinput</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">readinput(file)</code></pre><p>Reads input parameters from a <code>file</code>.</p><p>The expected amount of parameters can be addressed with <a href="#JuSwalbe.Inputconstants"><code>Inputconstants</code></a>. For now it expects seven values for different runtime constants.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe, DelimitedFiles

julia&gt; args = [&quot;Lattice_points_x&quot; 10; &quot;Lattice_points_y&quot; 5; &quot;Max_run_time&quot; 1000; &quot;Output_dump&quot; 100; &quot;Relaxation_rate&quot; 1.0; &quot;gravity&quot; 0.0; &quot;surface_tension&quot; 0.01; &quot;slippage&quot; 1.0] # Generate a text file with input
8×2 Array{Any,2}:
 &quot;Lattice_points_x&quot;    10
 &quot;Lattice_points_y&quot;     5
 &quot;Max_run_time&quot;      1000
 &quot;Output_dump&quot;        100
 &quot;Relaxation_rate&quot;      1.0
 &quot;gravity&quot;              0.0
 &quot;surface_tension&quot;      0.01
 &quot;slippage&quot;             1.0

julia&gt; writedlm(&quot;test.txt&quot;, args)

julia&gt; test = readinput(&quot;test.txt&quot;)
JuSwalbe.Inputconstants
  lx: Int64 10
  ly: Int64 5
  maxruntime: Int64 1000
  dumping: Int64 100
  τ: Float64 1.0
  gravity: Float64 0.0
  γ: Float64 0.01
  δ: Float64 1.0
  μ: Float64 0.16666666666666666

julia&gt; test.lx
10

julia&gt; test.γ
0.01

julia&gt; test.γ + test.δ
1.01

julia&gt; isa(test.lx + test.gravity, Int32)
false

julia&gt; rm(&quot;test.txt&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/readinput.jl#L56-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.savecheckpoint-Tuple{JuSwalbe.Distributionfunction}" href="#JuSwalbe.savecheckpoint-Tuple{JuSwalbe.Distributionfunction}"><code>JuSwalbe.savecheckpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">savecheckpoint(dist, t)</code></pre><p>Saves the distribution function to a binary file. </p><p>This file can be seen as a checkpoint or snapshot of the simulations internal state and be used to restart the simulation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; dist = JuSwalbe.DistributionD1Q3(f0 = ones(10), f1 = fill(0.1, 10), f2 = fill(-0.1, 10))
JuSwalbe.DistributionD1Q3{Array{Float64,1}}
  f0: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
  f1: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
  f2: Array{Float64}((10,)) [-0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1]

julia&gt; savecheckpoint(dist)

julia&gt; isfile(&quot;data/tmp/checkpoint_0.bson&quot;)
true

julia&gt; load_dist = loadcheckpoint(&quot;data/tmp/checkpoint_0.bson&quot;)
JuSwalbe.DistributionD1Q3{Array{Float64,1}}
  f0: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
  f1: Array{Float64}((10,)) [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]
  f2: Array{Float64}((10,)) [-0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1]

julia&gt; load_dist.f0 == dist.f0; load_dist.f1 == dist.f1; load_dist.f2 == dist.f2
true

julia&gt; rm(&quot;data/tmp/checkpoint_0.bson&quot;)</code></pre><p>See also: <a href="#JuSwalbe.loadcheckpoint-Tuple{Any}"><code>loadcheckpoint</code></a></p><p><strong>Additional information</strong></p><p>The size of the checkpoint heavily depends on the system size. In case of two spatial dimensions and a 4096^2 lattice a single checkpoint file for a Float64 simulation is about 1.2GB data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/readwritedata.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.savecheckpoints-Tuple{JuSwalbe.Distributionfunction}" href="#JuSwalbe.savecheckpoints-Tuple{JuSwalbe.Distributionfunction}"><code>JuSwalbe.savecheckpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">savecheckpoints(dist, name, t)</code></pre><p>Same as savecheckpoint but does not delete the previous checkpoint files.</p><p>See also <a href="#JuSwalbe.savecheckpoint-Tuple{JuSwalbe.Distributionfunction}"><code>savecheckpoint</code></a>, <a href="#JuSwalbe.loadcheckpoint-Tuple{Any}"><code>loadcheckpoint</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/readwritedata.jl#L54-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.simpleTwovector-Tuple{Int64,Int64}" href="#JuSwalbe.simpleTwovector-Tuple{Int64,Int64}"><code>JuSwalbe.simpleTwovector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>simpleTwovector(n,m,T)</p><p>Generates a JuSwalbe.Twovector of type T and dimension (n,m).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; twovec = simpleTwovector(5,5)
JuSwalbe.Twovector{Array{Float64,2}}
  x: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  y: Array{Float64}((5, 5)) [-0.1 -0.1 … -0.1 -0.1; -0.1 -0.1 … -0.1 -0.1; … ; -0.1 -0.1 … -0.1 -0.1; -0.1 -0.1 … -0.1 -0.1]

julia&gt; twovec.x
5×5 Array{Float64,2}:
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/minimalsetup.jl#L152-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.simpledistD2Q9-Tuple{Int64,Int64}" href="#JuSwalbe.simpledistD2Q9-Tuple{Int64,Int64}"><code>JuSwalbe.simpledistD2Q9</code></a> — <span class="docstring-category">Method</span></header><section><div><p>simpledistD2Q9(n, m, T)</p><p>Generates a <code>D2Q9</code> distribution function of dimension <code>n</code>,<code>m</code> with defined fill statements.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; dist = simpledistD2Q9(5,5)
JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  f1: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f2: Array{Float64}((5, 5)) [-0.1 -0.1 … -0.1 -0.1; -0.1 -0.1 … -0.1 -0.1; … ; -0.1 -0.1 … -0.1 -0.1; -0.1 -0.1 … -0.1 -0.1]
  f3: Array{Float64}((5, 5)) [0.01 0.01 … 0.01 0.01; 0.01 0.01 … 0.01 0.01; … ; 0.01 0.01 … 0.01 0.01; 0.01 0.01 … 0.01 0.01]
  f4: Array{Float64}((5, 5)) [-0.01 -0.01 … -0.01 -0.01; -0.01 -0.01 … -0.01 -0.01; … ; -0.01 -0.01 … -0.01 -0.01; -0.01 -0.01 … -0.01 -0.01]
  f5: Array{Float64}((5, 5)) [0.2 0.2 … 0.2 0.2; 0.2 0.2 … 0.2 0.2; … ; 0.2 0.2 … 0.2 0.2; 0.2 0.2 … 0.2 0.2]
  f6: Array{Float64}((5, 5)) [0.02 0.02 … 0.02 0.02; 0.02 0.02 … 0.02 0.02; … ; 0.02 0.02 … 0.02 0.02; 0.02 0.02 … 0.02 0.02]
  f7: Array{Float64}((5, 5)) [0.02 0.02 … 0.02 0.02; 0.02 0.02 … 0.02 0.02; … ; 0.02 0.02 … 0.02 0.02; 0.02 0.02 … 0.02 0.02]
  f8: Array{Float64}((5, 5)) [0.5 0.5 … 0.5 0.5; 0.5 0.5 … 0.5 0.5; … ; 0.5 0.5 … 0.5 0.5; 0.5 0.5 … 0.5 0.5]

julia&gt; dist.f0
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0

julia&gt; typeof(dist)
JuSwalbe.DistributionD2Q9{Array{Float64,2}}</code></pre><p>See also: <a href="#JuSwalbe.simpleTwovector-Tuple{Int64,Int64}"><code>simpleTwovector</code></a>, <a href="#JuSwalbe.simplemoment2d-Tuple{Int64,Int64}"><code>simplemoment2d</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/minimalsetup.jl#L180-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.simplemoment2d-Tuple{Int64,Int64}" href="#JuSwalbe.simplemoment2d-Tuple{Int64,Int64}"><code>JuSwalbe.simplemoment2d</code></a> — <span class="docstring-category">Method</span></header><section><div><p>simplemoment2d(n,m,type)</p><p>Creates moments of type JuSwalbe.Macroquant with dimensions (n,m).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; mom = simplemoment2d(5,5)
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  energy: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; mom.height
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/minimalsetup.jl#L121-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.streamdistperiodic!-Union{Tuple{JuSwalbe.DistributionD1Q3{Array{T,1}}}, Tuple{T}} where T&lt;:Number" href="#JuSwalbe.streamdistperiodic!-Union{Tuple{JuSwalbe.DistributionD1Q3{Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>JuSwalbe.streamdistperiodic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">streamdistperiodic!(dist)</code></pre><p>Streams the lattice Boltzmann distribution accoriding to their velocity vector.</p><p>The so called streaming process transports the distribution functions according to thier lattice velocity. In one dimension this means that the zero velocity distribution stays at its lattice point while the positive velocity advances by one lattice node. Of course the negative velocity component <code>.f2</code> decreases its lattice index by one.</p><p>In two dimensions there are nine of these operations according to the <code>D2Q9</code> lattice vectors.</p><p><strong>Math</strong></p><p>After the collision process the newly calculated distribution functions need to be streamed. They performe one interation or streaming per time update. Such the distributions after collision <span>$f^{\ast}_i$</span> are transported to their respective new position</p><p><span>$f^{\ast}_i(\mathbf{x} + \mathbf{c}_i \Delta t)$</span></p><p>One has to be careful in the proximity of boundaries, because they could destroy mass which is unphysical.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; dist = JuSwalbe.DistributionD2Q9(f0=ones(5,5), f1=fill(0.1, (5,5)), f2=fill(0.1, (5,5)),
                                        f3=fill(0.1, (5,5)), f4=fill(0.1, (5,5)), f5=zeros(5,5),
                                        f6=zeros(5,5), f7=zeros(5,5), f8=zeros(5,5))
JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  f1: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f2: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f3: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f4: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f5: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f6: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f7: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f8: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
   
julia&gt; dist.f1[2,2] = 1; dist.f2[2,2] = 1; dist.f5[2,2] = 1; dist.f3[2,2] = 1; dist.f8[2,2] = 1 
1

julia&gt; newdist = streamdistperiodic!(dist)
JuSwalbe.DistributionD2Q9{Array{Float64,2}}
  f0: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  f1: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f2: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f3: Array{Float64}((5, 5)) [0.1 1.0 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f4: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  f5: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f6: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f7: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  f8: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; dist.f1
5×5 Array{Float64,2}:
 0.1  0.1  0.1  0.1  0.1
 0.1  1.0  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1

julia&gt; newdist.f1
5×5 Array{Float64,2}:
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  1.0  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1

julia&gt; dist.f8
5×5 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0

julia&gt; newdist.f8
5×5 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 </code></pre><p><strong>References</strong></p><p>Any book on the lattice Boltzmann method should do.</p><ul><li><a href="https://www.springer.com/gp/book/9783319446479">The Lattice Boltzmann Method: Principles and Practice</a></li></ul><p>See also <a href="#JuSwalbe.collisionBGK-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}},JuSwalbe.DistributionD1Q3{Array{T,1}},JuSwalbe.Inputconstants}} where T&lt;:Number"><code>collisionBGK</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/collide.jl#L287-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.velocity2file-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number" href="#JuSwalbe.velocity2file-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>JuSwalbe.velocity2file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">velocity2file(mom, name, time)</code></pre><p>Saves the velocity field to a binary file called velocity_time.bson.</p><p>Independent of the dimensionality of the system, <code>D1Q3</code>, <code>D2Q9</code> saves the velocity to a file. In case of <code>D2Q9</code> saves both velocity components to the file such <code>velocity.x</code> and <code>velocity.y</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe, BSON

julia&gt; mom = simplemoment2d(5,5)
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  energy: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; velocity2file(mom)

julia&gt; vel = BSON.load(&quot;data/tmp/velocity_0.bson&quot;)
Dict{Symbol,Any} with 2 entries:
  :velocity_x =&gt; [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; …
  :velocity_y =&gt; [-0.1 -0.1 … -0.1 -0.1; -0.1 -0.1 … -0.1 -0.1; … ; -0.1 -0.1 ……

julia&gt; vel[:velocity_x]
5×5 Array{Float64,2}:
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1

julia&gt; v = JuSwalbe.Twovector(x = vel[:velocity_x], y = vel[:velocity_y])
JuSwalbe.Twovector{Array{Float64,2}}
  x: Array{Float64}((5, 5)) [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1]
  y: Array{Float64}((5, 5)) [-0.1 -0.1 … -0.1 -0.1; -0.1 -0.1 … -0.1 -0.1; … ; -0.1 -0.1 … -0.1 -0.1; -0.1 -0.1 … -0.1 -0.1]

julia&gt; rm(&quot;data/tmp/velocity_0.bson&quot;)</code></pre><p>See also: <a href="#JuSwalbe.height2file-Tuple{JuSwalbe.Macroscopic_quantity}"><code>height2file</code></a>, <a href="#JuSwalbe.savecheckpoint-Tuple{JuSwalbe.Distributionfunction}"><code>savecheckpoint</code></a>, <a href="#JuSwalbe.velocityandheight2file-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>velocityandheight2file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/readwritedata.jl#L151-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.velocityandheight2file-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number" href="#JuSwalbe.velocityandheight2file-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>JuSwalbe.velocityandheight2file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">velocityandheight2file(mom, name, time)</code></pre><p>Saves the velocity as well as the height field to a binary file called height<em>velocity</em>time.bson.</p><p>Independent of the dimensionality of the system, <code>D1Q3</code>, <code>D2Q9</code> saves the velocity and height to a file. In case of <code>D2Q9</code> saves both velocity components to the file such <code>velocity.x</code> and <code>velocity.y</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe, BSON

julia&gt; mom = simplemoment2d(5,5)
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  energy: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; velocityandheight2file(mom)

julia&gt; h_vel = BSON.load(&quot;data/tmp/height_velocity_0.bson&quot;)
Dict{Symbol,Any} with 3 entries:
  :height     =&gt; [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; …
  :velocity_x =&gt; [0.1 0.1 … 0.1 0.1; 0.1 0.1 … 0.1 0.1; … ; 0.1 0.1 … 0.1 0.1; …
  :velocity_y =&gt; [-0.1 -0.1 … -0.1 -0.1; -0.1 -0.1 … -0.1 -0.1; … ; -0.1 -0.1 ……

julia&gt; h_vel[:height]
5×5 Array{Float64,2}:
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0  1.0
 
julia&gt; h_vel[:velocity_x]
5×5 Array{Float64,2}:
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1  0.1

julia&gt; rm(&quot;data/tmp/height_velocity_0.bson&quot;)
</code></pre><p>See also: <a href="#JuSwalbe.height2file-Tuple{JuSwalbe.Macroscopic_quantity}"><code>height2file</code></a>, <a href="#JuSwalbe.savecheckpoint-Tuple{JuSwalbe.Distributionfunction}"><code>savecheckpoint</code></a>, <a href="#JuSwalbe.velocityandheight2file-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>velocityandheight2file</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/readwritedata.jl#L210-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.Δh-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number" href="#JuSwalbe.Δh-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number"><code>JuSwalbe.Δh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Δh(mom::JuSwalbe.Macroquant)</code></pre><p>Calculates the laplacian of the height field with periodic boundaries.</p><p>The calculation of the laplacian is central for the thin film evolution. Only the pressure gradient will induce a flow, at least for the non-fluctuating version. Therefore it is fairly important to have an accurate computation of the laplacian.</p><p><strong>Math</strong></p><p>The Laplace equation is given by </p><p><span>$\Delta \rho = 0$</span></p><p>The laplace operator is simply Δ = ∇ . ∇.  Since the film pressure has a contribution Δh we need a discreticed laplace operator.</p><p><strong>Two spatial dimensions</strong></p><p>In two dimensions I follow the paper from Santosh and Succi. A nine-point stencil is used and the equation goes as follow</p><p><span>$\Delta h_{i,j} = \frac{1}{6}[4\sum_{nn}h_{i,j} + sum_{diag}h_{i,j} - 20 h_{i,j}]$</span></p><p>Where <code>i</code> and <code>j</code> are the x and y coordinates. The index <code>nn</code> relates to the nearest neighbors, all four elements which are exactly Δx away from (i,j). On the other hand the diagonal elements are those four which are have a distance √2Δx to (i,j).  Periodicity is taken care of by a circular padding of the height array. </p><p><strong>One spatial dimension</strong></p><p>For a single spatial dimension it is mostly sufficient to use the central difference approach. This approach is given by</p><p>`` \partial<em>x^2 h</em>{i} = h<em>{i-1} - 2h</em>{i} + h_{i+1}</p><p>with <code>i</code> being the index along the spatial dimension.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; height = reshape(collect(1.0:16.0), (4,4))
4×4 Array{Float64,2}:
 1.0  5.0   9.0  13.0
 2.0  6.0  10.0  14.0
 3.0  7.0  11.0  15.0
 4.0  8.0  12.0  16.0

julia&gt; velx = zeros(Float64, (4,4))
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia&gt; vely = zeros(Float64, (4,4))
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 
julia&gt; vel = JuSwalbe.Twovector(x=velx, y=vely)
JuSwalbe.Twovector{Array{Float64,2}}
  x: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]
  y: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]


julia&gt; moment = JuSwalbe.Macroquant(height=height, velocity=vel, pressure=zeros(4,4), energy=zeros(4,4))
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((4, 4)) [1.0 5.0 9.0 13.0; 2.0 6.0 10.0 14.0; 3.0 7.0 11.0 15.0; 4.0 8.0 12.0 16.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]
  energy: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]


julia&gt; moment.height
4×4 Array{Float64,2}:
 1.0  5.0   9.0  13.0
 2.0  6.0  10.0  14.0
 3.0  7.0  11.0  15.0
 4.0  8.0  12.0  16.0

julia&gt; laplace = Δh(moment)
4×4 Array{Float64,2}:
 20.0   4.0   4.0  -12.0
 16.0   0.0   0.0  -16.0
 16.0   0.0   0.0  -16.0
 12.0  -4.0  -4.0  -20.0

julia&gt; height = collect(1.0:16.0)
16-element Array{Float64,1}:
  1.0
  2.0
  3.0
  4.0
  5.0
  6.0
  7.0
  8.0
  9.0
 10.0
 11.0
 12.0
 13.0
 14.0
 15.0
 16.0

julia&gt; Δh(height)
16-element Array{Float64,1}:
  16.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
   0.0
 -16.0
</code></pre><p><strong>References</strong></p><p><strong>Two spatial dimensions</strong></p><p>There are plenty of papers concerning discret differentail operators. Many of them are good, although definitly not the best I go here with:</p><ul><li><a href="https://www.sciencedirect.com/science/article/pii/S0021999112004226">Isotropic discrete Laplacian operators from lattice hydrodynamics</a></li></ul><p><strong>One spatial dimension</strong></p><p>Almost any reference on discrete differentiation is good enough.</p><ul><li><a href="http://www2.math.umd.edu/~dlevy/classes/amsc466/lecture-notes/differentiation-chap.pdf">Numerical Differentiation</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/calculatepressure.jl#L454-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.Π-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number" href="#JuSwalbe.Π-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number"><code>JuSwalbe.Π</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Π(mom::JuSwalbe.Macroquant; h_star = 0.1, exponents = [9,3], γ = 0.01, θ = 1.0/9.0)</code></pre><p>Calculates the disjoining pressure for a given surface tension and contact angle at every lattice point.</p><p>The disjoing pressure potential enables the simulation to study phenomena like dewetting of thin liquid films. Only with this potential it is possible to &quot;dewett&quot; without using highly sophisticated boundary conditions at <span>$h\rightarrow 0$</span>. The functional shape of this potential can vary, ranging from the powerlaw used here to exponentials to a mixture of both. Using the powerlaw shape the exponents (9,3) mimic the Lenard-Jones potential for the liquid substrate interaction.</p><p><strong>Arguments</strong></p><ul><li><code>mom::JuSwalbe.Macroquant</code> : Macroscopic moments of the simulation, important here <code>.height</code> which contains the height field. Allows for array input as well.</li><li><code>h_star::T</code> : Minimum of the pontential. T needs to be a subtype of <code>Number</code>! </li><li><code>exponents::Array{Int64,1}</code> : Exponents for the powerlaw potential</li><li><code>γ::T</code> : Surface tension</li><li><code>θ::T</code> : Equilibrium contact angle in multiple of π (for accuarcy reasons). Needs to be an array when doing patterning. For simple substrate use a one entry array with correct dimension.</li></ul><p><strong>Math</strong></p><p>The potential can be derived from the assumption that a given surface energy demands an equilibrium contact angle for the fluid. For the exact derivation take a look at the references, in principle it is the derivative of the interfacial potential with respect to <code>h</code>.</p><p><span>$\Phi&#39;(h) = \Pi(h)$</span> </p><p><span>$\Pi(h) = \kappa f(h) = (1-\cos\theta)\frac{(n-1)(m-1)}{(n-m)h_{\ast}}\Bigg[\Bigg(\frac{h_{\ast}}{h}\Bigg)^n - \Bigg(\frac{h_{\ast}}{h}\Bigg)^m\Bigg]$</span></p><p><span>$\Pi(h_{\ast}) = 0$</span> </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; n,m = (4,4)
(4, 4)

julia&gt; moment = JuSwalbe.Macroquant(height=ones(n,m), velocity=JuSwalbe.Twovector(x=zeros(n,m), y=zeros(n,m)), pressure=zeros(n,m), energy=zeros(n,m))
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((4, 4)) [1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]
  energy: Array{Float64}((4, 4)) [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0]

julia&gt; p = Π(moment)
4×4 Array{Float64,2}:
 -1.6082e-5  -1.6082e-5  -1.6082e-5  -1.6082e-5
 -1.6082e-5  -1.6082e-5  -1.6082e-5  -1.6082e-5
 -1.6082e-5  -1.6082e-5  -1.6082e-5  -1.6082e-5
 -1.6082e-5  -1.6082e-5  -1.6082e-5  -1.6082e-5

julia&gt; p = Π(moment, θ=zeros(1,1)) # Fully wetting substrate
4×4 Array{Float64,2}:
 -0.0  -0.0  -0.0  -0.0
 -0.0  -0.0  -0.0  -0.0
 -0.0  -0.0  -0.0  -0.0
 -0.0  -0.0  -0.0  -0.0

julia&gt; h = reshape([i for i in 1.0:(n*m)],n,m)
4×4 Array{Float64,2}:
 1.0  5.0   9.0  13.0
 2.0  6.0  10.0  14.0
 3.0  7.0  11.0  15.0
 4.0  8.0  12.0  16.0

julia&gt; p = Π(h)
4×4 Array{Float64,2}:
 -1.6082e-5   -1.28656e-7  -2.20603e-8  -7.31997e-9
 -2.01025e-6  -7.44536e-8  -1.6082e-8   -5.86078e-9
 -5.95628e-7  -4.68862e-8  -1.20826e-8  -4.76503e-9
 -2.51281e-7  -3.14101e-8  -9.30669e-9  -3.92626e-9
</code></pre><p><strong>References</strong></p><p>To get a good understanding:</p><ul><li><a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.69.931">Long-scale evolution of thin liquid films</a></li><li><a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.81.739">Wetting and spreading</a></li><li><a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.81.1131">Dynamics and stability of thin liquid films</a></li></ul><p>A rather recent new setup for the shape of <code>Π</code> can be found in </p><ul><li><a href="https://www.pnas.org/content/116/19/9275">Signatures of slip in dewetting polymer films</a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/calculatepressure.jl#L330-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.∇p-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}}}} where T&lt;:Number" href="#JuSwalbe.∇p-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}}}} where T&lt;:Number"><code>JuSwalbe.∇p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">∇p(mom::JuSwalbe.Macroquant)</code></pre><p>Computation of the pressure gradient in one and two spatial dimensions.</p><p>Given a struct <code>Macroquant</code> with an <code>.pressure</code> entry performs a finite difference approximation of the spatial derivative. A five-point stencil is used for one spatial dimension. For two spatial dimensions a weighted nine-point stencil is applied. An perodicity around the edges is assumed (ring, torus).</p><p><strong>Math</strong></p><p>Since this is essentially discrete operators I will not go into details.</p><p><strong>Two spatial dimensions</strong></p><p><span>$\nabla p = 3 \sum_{i=0}^8 w_i \mathbf{c}_i p(\mathbf{r}+\mathbf{c}_i) +O(\nabla^3).$</span></p><p>Where <span>$\mathbf{c}_i, w_i$</span> are the standard D2Q9 lattice velocities and weights. Of course this vector <span>$\nabla p$</span> needs to be multiple with the height field to yield the correct force.</p><p><strong>One spatial dimension</strong></p><p><span>$\partial_x p = \frac{p(x-2\Delta x) - 8p(x-1\Delta x) + 0p(x) + 8p(x+1\Delta x) - p(x+2\Delta x)}{12\Delta x} + O(\partial_x^5).$</span></p><p>Where the step size is limited by the resolution of the lattice Boltzmann grid <span>$\Delta x$</span>.</p><p><strong>Example</strong></p><p><strong>Two spatial dimensions</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; zerovelocity = JuSwalbe.Twovector(x=zeros(5,5), y=zeros(5,5)) # Thanks to @with_kw macro
JuSwalbe.Twovector{Array{Float64,2}}
  x: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  y: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; mom = JuSwalbe.Macroquant(height=fill(1.0, (5,5)), velocity=zerovelocity, pressure=zerovelocity.x, energy=zerovelocity.y)
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((5, 5)) [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]
  energy: Array{Float64}((5, 5)) [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0]

julia&gt; mom.height[2,3] = 2.0; mom.height[3,2] = 2.0; mom.height[4,3] = 2.0; mom.height[3,4] = 2.0
2.0

julia&gt; p = pressure(mom)
5×5 Array{Float64,2}:
 -1.6082e-5   -0.00168275  -0.00668275  -0.00168275  -1.6082e-5
 -0.00168275  -0.0133494    0.029998    -0.0133494   -0.00168275
 -0.00668275   0.029998    -0.0266827    0.029998    -0.00668275
 -0.00168275  -0.0133494    0.029998    -0.0133494   -0.00168275
 -1.6082e-5   -0.00168275  -0.00668275  -0.00168275  -1.6082e-5

julia&gt; mom.pressure
5×5 Array{Float64,2}:
 -1.6082e-5   -0.00168275  -0.00668275  -0.00168275  -1.6082e-5
 -0.00168275  -0.0133494    0.029998    -0.0133494   -0.00168275
 -0.00668275   0.029998    -0.0266827    0.029998    -0.00668275
 -0.00168275  -0.0133494    0.029998    -0.0133494   -0.00168275
 -1.6082e-5   -0.00168275  -0.00668275  -0.00168275  -1.6082e-5

julia&gt; f = JuSwalbe.Forces(slip=zerovelocity, h∇p=zerovelocity, thermal=zerovelocity, bathymetry=zerovelocity)
JuSwalbe.Forces{JuSwalbe.Twovector{Array{Float64,2}}}
  slip: JuSwalbe.Twovector{Array{Float64,2}}
  h∇p: JuSwalbe.Twovector{Array{Float64,2}}
  bathymetry: JuSwalbe.Twovector{Array{Float64,2}}
  thermal: JuSwalbe.Twovector{Array{Float64,2}}

julia&gt; gradp = ∇p(mom, f)
5×5×2 Array{Float64,3}:
[:, :, 1] =
 -0.00166667   -0.00097105   0.0102825   -0.00097105  -0.00166667
 -0.000137716   0.00833802  -0.00277309   0.00833802  -0.000137716
  0.0           0.0          0.0          0.0          0.0
  0.000137716  -0.00833802   0.00277309  -0.00833802   0.000137716
  0.00166667    0.00097105  -0.0102825    0.00097105   0.00166667

[:, :, 2] =
 -0.00166667  -0.000137716  0.0   0.000137716   0.00166667
 -0.00097105   0.00833802   0.0  -0.00833802    0.00097105
  0.0102825   -0.00277309   0.0   0.00277309   -0.0102825
 -0.00097105   0.00833802   0.0  -0.00833802    0.00097105
 -0.00166667  -0.000137716  0.0   0.000137716   0.00166667

julia&gt; f.h∇p.x
5×5 Array{Float64,2}:
 -0.00166667   -0.00097105   0.0102825   -0.00097105  -0.00166667
 -0.000137716   0.00833802  -0.00277309   0.00833802  -0.000137716
  0.0           0.0          0.0          0.0          0.0
  0.000137716  -0.00833802   0.00277309  -0.00833802   0.000137716
  0.00166667    0.00097105  -0.0102825    0.00097105   0.00166667

julia&gt; f.h∇p.y
5×5 Array{Float64,2}:
 -0.00166667  -0.000137716  0.0   0.000137716   0.00166667
 -0.00097105   0.00833802   0.0  -0.00833802    0.00097105
  0.0102825   -0.00277309   0.0   0.00277309   -0.0102825
 -0.00097105   0.00833802   0.0  -0.00833802    0.00097105
 -0.00166667  -0.000137716  0.0   0.000137716   0.00166667
 </code></pre><p><strong>One spatial dimension</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; mom = JuSwalbe.Macroquant(height=ones(10), velocity=zeros(10), pressure=zeros(10), energy=zeros(10))
JuSwalbe.Macroquant{Array{Float64,1},Array{Float64,1}}
  height: Array{Float64}((10,)) [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
  velocity: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  pressure: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  energy: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

julia&gt; f = JuSwalbe.Forces(slip=zeros(10), h∇p=zeros(10), thermal=zeros(10), bathymetry=zeros(10))
JuSwalbe.Forces{Array{Float64,1}}
  slip: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  h∇p: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  bathymetry: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  thermal: Array{Float64}((10,)) [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

julia&gt; mom.height[4] = 0.5; mom.height[5] = 2.0; mom.height[6] = 0.5; 

julia&gt; p = pressure(mom, θ=zeros(1), γ=1.0)
10-element Array{Float64,1}:
 -0.0
 -0.0
  0.5
 -2.0
  3.0
 -2.0
  0.5
 -0.0
 -0.0
 -0.0

julia&gt; gradp = ∇p(mom, f)
10-element Array{Float64,1}:
 -0.041666666666666664
  0.5
 -1.5833333333333333
  0.9166666666666666
  0.0
 -0.9166666666666666
  1.5833333333333333
 -0.5
  0.041666666666666664
  0.0
  
</code></pre><p><strong>References</strong></p><p><strong>Two spatial dimensions</strong></p><ul><li><a href="https://www.sciencedirect.com/science/article/pii/S0021999112004226">Isotropic discrete Laplacian operators from lattice hydrodynamics</a></li><li><a href="https://epubs.siam.org/doi/abs/10.1137/S1064827599357188">Discretizations for the Incompressible Navier–Stokes Equations Based on the Lattice Boltzmann Method</a></li></ul><p>The second reference is the older and more mathematically one, while the first reference is short and great for a fast look up.</p><p><strong>One spatial dimension</strong></p><ul><li><a href="http://www2.math.umd.edu/~dlevy/classes/amsc466/lecture-notes/differentiation-chap.pdf">Numerical Differentiation</a></li></ul><p>Any lecture notes or book on discrete mathematics should do for the one dimensional case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/calculatepressure.jl#L119-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.velocitysquared-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number" href="#JuSwalbe.velocitysquared-Union{Tuple{JuSwalbe.Macroquant{Array{T,2},JuSwalbe.Twovector{Array{T,2}}}}, Tuple{T}} where T&lt;:Number"><code>JuSwalbe.velocitysquared</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">velocitysquared(mom::Macroquant{Matrix{T}, JuSwalbe.Twovector{Matrix{T}}})</code></pre><p>Computes the square of the velocity vector (ux, uy) at every lattice point.</p><p>The magnitude of the velocity is needed to calculate the equilibrium distribution in the dimensional case. In the one dimensional case the velocity is just a vector and therefore has no <code>.x</code> and <code>.y</code> component. See also <a href="#JuSwalbe.calc_equilibrium_distribution-Union{Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}}}, Tuple{T}} where T&lt;:Number"><code>calc_equilibrium_distribution</code></a></p><p><strong>Math</strong></p><p>The velocity squared <span>$u^2(x,y)$</span> is computed according to </p><p><span>$u^2(x,y) = (u_x, u_y)^2(x,y) = u_x^2(x,y) + u_y^2(x,y).$</span></p><p>With lower case <code>x</code> and <code>y</code> the respective component of the velocity vector is addressed.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; velocities = JuSwalbe.Twovector{Matrix{Float64}}(x=fill(0.1, (4,4)), y=fill(0.2, (4,4)))
JuSwalbe.Twovector{Array{Float64,2}}
  x: Array{Float64}((4, 4)) [0.1 0.1 0.1 0.1; 0.1 0.1 0.1 0.1; 0.1 0.1 0.1 0.1; 0.1 0.1 0.1 0.1]
  y: Array{Float64}((4, 4)) [0.2 0.2 0.2 0.2; 0.2 0.2 0.2 0.2; 0.2 0.2 0.2 0.2; 0.2 0.2 0.2 0.2]

julia&gt; moment = JuSwalbe.Macroquant(height=ones(Float64, (4,4)), velocity=velocities, pressure=ones(Float64, (4,4)), energy=ones(Float64, (4,4)))
JuSwalbe.Macroquant{Array{Float64,2},JuSwalbe.Twovector{Array{Float64,2}}}
  height: Array{Float64}((4, 4)) [1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0]
  velocity: JuSwalbe.Twovector{Array{Float64,2}}
  pressure: Array{Float64}((4, 4)) [1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0]
  energy: Array{Float64}((4, 4)) [1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0]

julia&gt; moment.velocity.x
4×4 Array{Float64,2}:
 0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1
 0.1  0.1  0.1  0.1

julia&gt; JuSwalbe.velocitysquared(moment)
4×4 Array{Float64,2}:
 0.05  0.05  0.05  0.05
 0.05  0.05  0.05  0.05
 0.05  0.05  0.05  0.05
 0.05  0.05  0.05  0.05</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/equilibriumcalculation.jl#L219-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.Inputconstants" href="#JuSwalbe.Inputconstants"><code>JuSwalbe.Inputconstants</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Inputconstants = new(lx, ly, maxruntime, dumping, gravity, γ, δ)</code></pre><p>Struct containing input parameters.</p><p>Contains <code>.lx</code> lattice points in x-direction, <code>.ly</code> lattice points in y-direction.  Other fields are <code>.maxruntime</code> for the maximal number of time steps and <code>.dumping</code> to limit the number of output files. On top of these there are physical quantities such as <code>.gravity</code>, <code>.γ</code> and <code>.δ</code>  for the values of gravitational acceleration, fluids surface tension and the slip length. The example relates to an quadratic lattice 20 times 20 lattice units in area.  Run for 100 lattice Boltzmann time steps only printing output every 10 time steps. Having no gravity and a surface tension of 0.01 and a slip length of 1.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using JuSwalbe

julia&gt; new_input = JuSwalbe.Inputconstants()
JuSwalbe.Inputconstants
  lx: Int64 512
  ly: Int64 512
  maxruntime: Int64 100000
  dumping: Int64 1000
  τ: Float64 1.0
  gravity: Float64 0.0
  γ: Float64 0.01
  δ: Float64 1.0
  μ: Float64 0.16666666666666666

julia&gt; new_input.γ
0.01</code></pre><p><strong>References</strong></p><p>See also: <a href="#JuSwalbe.readinput-Tuple{Any}"><code>readinput</code></a>, <a href="#JuSwalbe.findargument-Tuple{Array{Any,2},String}"><code>findargument</code></a>, <a href="#JuSwalbe.computeslip-Union{Tuple{T}, Tuple{JuSwalbe.Macroquant{Array{T,1},Array{T,1}},JuSwalbe.Forces{Array{T,1}},JuSwalbe.Inputconstants}} where T&lt;:Number"><code>computeslip</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuSwalbe.inputfile" href="#JuSwalbe.inputfile"><code>JuSwalbe.inputfile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">inputfile</code></pre><p>Abstract type for all kinds of input files</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Zitzeronion/JuSwalbe.jl/blob/2271db524c101dfcd182af5b1ae4b266ae1181ba/src/readinput.jl#L1-L5">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../reference/">References »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 25 May 2020 08:19">Monday 25 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
